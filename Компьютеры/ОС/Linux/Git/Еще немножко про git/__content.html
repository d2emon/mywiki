<!DOCTYPE html>
<HTML>
<HEAD>
	<META HTTP-EQUIV='CONTENT-TYPE' CONTENT='TEXT/HTML; CHARSET=UTF-8'/>

	<STYLE type="text/css">
		body, div, p, table {
			font-size:10pt;
			font-family:Verdana;
		}

		img{border:none}
		
	</STYLE>
	
</HEAD>

<BODY>
<P>
<H1>Еще немножко про git</H1></P>

<P>Перевели крупнейший наш проект с CVS на git. В связи с этим возникло много непониманий и вопросов о том, как теперь делать правильно. Никита разродился большим описанием предлагаемого workflow:</P>

<P><CODE>
<BR>Прежде чем расписывать сценарии, хотелось бы ещё раз обратить ваше
<BR>внимание на базовые свойства GIT:</P>

<P> *) Коммит ВСЕГДА делается только в ЛОКАЛЬНЫЙ репозиторий.</P>

<P> *) За исключением несущественных сейчас особых случаев, коммит ВСЕГДА делается
<BR>на ЛОКАЛЬНУЮ ветку. Напоминаю, что ветка - это фактически указатель на коммит;
<BR>в результате создания нового коммита текущая ветка начинает указывать на вновь
<BR>созданный коммит.</P>

<P>Это означает, что в git разработка делается на ветке ВСЕГДА. "Разработка на
<BR>trunk" (где под trunk понимается ветка в удалённом репозитории, например в
<BR>находящемся на git.lvk.cs.msu.su) физически невозможна.</P>

<P>Поэтому, правильно говорить не о "разработке на trunk" или на ещё какой-то
<BR>ветке в удалённом репозитории, а о синхронизации локальных веток с удалёнными.</P>

<P>Тут уже можно ставить вопросы:
<BR>- с какой удалённой веткой вы синхронизируетесь (с master или с какой-то ещё),
<BR>- когда вы это делаете.</P>

<P>То же самое, другими словами.</P>

<P>В CVS/SVN вы работали с двумя сущностями:</P>

<P>[рабочий каталог] < -> [общий репозиторий]</P>

<P>Всякое изменение в рабочем каталоге сохранить некуда, кроме как в общий
<BR>репозиторий. Если изменился общий репозиторий, то сохранить изменение вообще
<BR>нельзя, предварительно не выполнив операцию update (и не выполнив слияние при
<BR>необходимости).
<BR>Вопросы Макса явно предполагают именно эту схему.</P>

<P>Но в GIT схема другая, там три сущности:</P>

<P>[рабочий каталог] < -> [локальный репозиторий] < -> [удалённые репозитории]</P>

<P>Операции "сохранить текущую работу в виде коммита" и "синхронизироваться с
<BR>внешними изменениями" оказываются полностью независимыми друг от друга.</P>

<P>В локальном репозитории можно создавать любое количество коммитов,
<BR>расположенных на любом количестве веток, не оглядываясь на какие бы то ни было
<BR>изменения удалённых репозиториев.</P>

<P>Независимо от этого, любую из локальных веток можно различным образом
<BR>синхронизировать с какой-нибудь веткой в каком-нибудь удалённом репозитории.</P>

<P>А теперь попробую ответить на вопросы.</P>

<P>> Прежде всего, "основной сценарий" разработки некоторого модуля</P>

<P>Отталкиваться лучше не от начала дня, а от начала решения некоторой задачи (не
<BR>важно, 5 минут это займёт или месяц; неважно, сколько задач решается в
<BR>параллель).</P>

<P>Решение задачи лучше начинать с чистого рабочего каталога (то есть, в рабочем
<BR>каталоге не должно быть изменений, не сохранённых в локальном репозитории).
<BR>Проверить это можно командой 'git status'.</P>

<P>Возможно, рабочий каталог не чистый. Тоесть, в нём содержится частичное или
<BR>полное решение другой задачи. Обращаю внимание, что одной - смешивать в
<BR>рабочем каталоге решение нескольких задач абсолютно противопоказано.</P>

<P>Тогда есть варианты:</P>

<P>- не браться за новую задачу, не закончив старую
<BR>  - это не всегда возможно</P>

<P>- "cvs-стиль 1": смешать в рабочем каталоге решение старой задачи с решением
<BR>  новой
<BR>  - иногда прокатывает, но часто приводит к проблемам - например,
<BR>    если решение разных задач потребует модифицировать один и тот же файл</P>

<P>- "cvs-стиль 2": слить неготовое решение в "общий репозиторий"
<BR>  - и тогда остальные разработчики будут это расхлёбывать</P>

<P>- "cvs-стиль 3": заводить отдельный рабочий каталог на каждую задачу
<BR>  - неэффективно (долгая сборка, перерасход дискового пространства, куча
<BR>    мусора в каталогах со временем и т.д.)</P>

<P>- правильное решение: сохранить незаконченное решение в локальном репозитории,
<BR>  чтобы позже к нему вернуться.</P>

<P>Для реализации этого "правильного решения" git предоставляет целых два средства.</P>

<P>- Для простых случаев - git stash. Эта команда позволяет сохранить все
<BR>  изменения рабочего каталога в некоторый буфер, и откатить рабочий каталог к
<BR>  последнему коммиту. Позже изменения можно вернуть из буфера командой
<BR>  git stash apply. Буфера можно именовать, их может быть сколько угодно.</P>

<P>- Для более сложных случаев - например, когда ваше частичное решение уже
<BR>  содержит несколько коммитов в локальный репозиторий - лучше использовать
<BR>  обычный git commit. При этом изменения окажутся сохранены в ещё один коммит
<BR>  в локальный репозиторий. Что совершенно не страшно - позже, когда вы
<BR>  вернётесь к прерыванной задаче, этот локальный коммит можно будет заменить
<BR>  или удалить.</P>

<P>Итак, получили чистый рабочий каталог.</P>

<P>Дальше надо решить, на какой локальной ветке будет решение новой задачи:
<BR>- если вы не использовали git commit для сохранения частичных решений (то есть,
<BR>  если ваша текущая ветка не содержит "неопубликованных" коммитов, то можно её
<BR>  и использовать,
<BR>- если же у вас на текущей ветке есть "неопубликованные" коммиты, то придётся
<BR>  завести новую локальную ветку,
<BR>- а можно и всегда заводить новую локальную ветку, именуя её по решаемой
<BR>  задаче - так порядку будет больше.</P>

<P>Также, надо решить, с какой базы будет начинаться решение новой задачи.
<BR>Во многих случаях базой логично сделать текущее положение ветки master
<BR>репозитория на git.lvk.cs.msu.su - но, например, если делается фикс для
<BR>кода, поставленного заказчику, то база будет соответствующей.</P>

<P>Новая ветка, указывающая на текущее положение ветки master репозитория на
<BR>git.lvk.cs.msu.su, создаётся например так:</P>

<P>git fetch origin master
<BR>git branch new_task origin/master
<BR>git checkout new_task</P>

<P>Первая команда загружает в ваш локальный репозиторий возможные изменения ветки
<BR>master удалённого репозитория origin.
<BR>Вторая - создаёт локальную ветку new_task, указывающую на верхний коммит ветки
<BR>origin/master.
<BR>Третья - делает ветку new_task текущей (в частности, извлекает соответствующее
<BR>этой ветке дерево файлов из локального репозитория в рабочий каталог).</P>

<P>Ветку репозитория master можно не указывать. Если же базой для вашей ветки
<BR>является не master, а например, devel, то первые две команды
<BR>будут выглядить так:
<BR>git fetch origin devel
<BR>git branch fix_task origin/devel</P>

<P>Если же:</P>

<P>- у вас "однозадачный режим", то есть вся работа ведётся на локальной
<BR>  ветке master,
<BR>- это именно та локальная ветка master, которая образовалась в результате
<BR>  первоначально операции git clone, создавшей ваш репозиторий (то есть, вы её
<BR>  явно не переконфигурировали, не удаляли/пересоздавали и т.п.),</P>

<P>то достаточно [при чистом рабочем каталоге!] выполнить команду</P>

<P>git pull</P>

<P>При этом результат будет тот же самый - в ваш локальный репозиторий будут
<BR>загружены возможные изменения ветки master удалённого репозитория origin,
<BR>локальная ветка master станет указывать на текущее значение origin/master, и
<BR>рабочий каталог будет содержать текущее дерево файлов, соответствующее этой
<BR>ветке.</P>

<P>После этого можно работать - решать задачу.</P>

<P>В процессе решения задачи возможно придётся переключиться на другие задачи -
<BR>об этом см. выше.</P>

<P>Результатом решения задачи должен стать один или несколько коммитов на
<BR>локальной ветке, соответствующей этой задаче (или на локальной ветке master -
<BR>см. выше).</P>

<P>Теперь эти коммиты надо "опубликовать" - например, на ветку master репозитоиия
<BR>на git.lvk.cs.msu.su.</P>

<P>Перед публикацией обязательно надо ещё раз посмотреть получившуюся
<BR>последовательность коммитов. Возможно, там имеет смысл что-то поменять. Пока
<BR>коммиты локальные, это просто. Как именно это делается - отдельная тема, об
<BR>этом потом.</P>

<P>Публикация осуществляется командой</P>

<P>git push</P>

<P>(более полный синтаксис - git push remote_name local_branch:remote_branch - но
<BR>в описываемом сценарии все параметры должны быть подставлены по умолчанию)</P>

<P>При этом на уданённый репозиторий из локального репозитория (не из рабочего
<BR>каталога, а именно из локального репозитория) будут загружены объекты,
<BR>появившиеся в результате вашей работы. А затем будет сделана попытка
<BR>продвинуть удалённую ветку.</P>

<P>Вот тут возможны два варианта.</P>

<P>Если с момента начала решения вами вашей задачи удалённую ветку никто не
<BR>продвинул, то операция закончится успехом.</P>

<P>А если нет, то будет сообщение об ошибке "not fast-forward".</P>

<P>НИ В КОЕМ СЛУЧАЕ нельзя в ответ передавать команде git push ключ -f (force) -
<BR>ЭТО ПРИВЕДЁТ К ПОТЕРЕ КОММИТОВ между вашей базой и текущим состоянием ветки.
<BR>Физически данные не потеряются, но без специальных мер они не будут
<BR>видны.
<BR>Видимо, правильно будет запретить force на важных ветках на уровне pre-receive
<BR>hook - подумаем над этим.</P>

<P>Правильных решений при ошибке "not fast-forward" в ответ на git push может
<BR>быть два - rebase и merge.
<BR>В большинстве случаев из них нужно выбрать rebase.
<BR>Смысл этой операции вот в чём.</P>

<P>Когда вы начали решение задачи, состояние дерева коммитов было таким:</P>

<P>... - (*) - (M)</P>

<P>В результате вашей работы оно стало таким:</P>

<P>... - (*) - (M)
<BR>                            (1) - ... - (K)</P>

<P>Внизу - несколько коммитов, составляющих решение вашей задачи.</P>

<P>А в результате действий кого-то другого оно стало таким:</P>

<P>... - (*) - (M) - ... - (N)
<BR>                            (1) - ... - (K)</P>

<P>Эти схемы изображают именно деревья коммитов. Одно и то же дерево коммитов
<BR>хранится в разных репозиториях.</P>

<P>Операция rebase - это ЗАМЕНА созданной вами последовательности коммитов на
<BR>ДРУГУЮ, в которой патчи будут по возможности те же, а родительские отношения -
<BR>другие. Цель - получить вот это:</P>

<P>... - (*) - (M) - ... - (N)
<BR>                                                    (1) - ... - (K)</P>

<P>Если это проделать, то последующая операция git push закончится без ошибки, и
<BR>приведёт к</P>

<P>... - (*) - (M) - ... - (N) - (1) - ... - (K)</P>

<P>Теперь - как проделать операцию rebase.
<BR>В этой операции задействован рабочий каталог. Соответвенно, начинать её надо с
<BR>"чистого" состояния рабочего каталога. Впрочем, нет причин начинать публикацию
<BR>не с чистого.</P>

<P>Операция выполняется так (если удалённая ветка - именно origin/master):</P>

<P>git fetch origin
<BR>git rebase origin/master</P>

<P>Первая команда загрузит в локальный репозиторий новые коммиты, появившиеся в
<BR>ветке master репозитория origin. Эта операция абсолютно недеструктивна - она
<BR>только помещает новые объекты в локальный репозиторий и продвигает сохранённую
<BR>в локальном репозитории ссылку origin/master.</P>

<P>Вторая команда пытается выполнить требуемую замену последовательности
<BR>коммитов. При этом делается следующее:
<BR>- создаётся временная локальная ветка, указывающая на точку N,
<BR>- эта временная ветка извлекается в рабочий каталог,
<BR>- на временную ветку последовательно применяются (cherry-pick) коммиты из
<BR>  заменяемой последовательности
<BR>- после этого ваша локальная ветка (как ссылка) подменяется вновь созданной.</P>

<P>В процессе rebase-а возможны конфликты. В этом случае их надо разрешить
<BR>вручную, после чего продолжить rebase командой git rebase --continue.
<BR>Если на каком-то этапе разрешить конфликт не получается, можно отменить всю
<BR>операцию rebase при помощи git rebase --abort. Краткая подсказка выдаётся
<BR>вместе с сообщением о конфликте. Полностью все возможности можно посмотреть
<BR>через git help rebase.</P>

<P>Вот в общем-то и всё.</P>

<P>Чтобы вернуться к старой задаче, которую вы прервали, начав эту, достаточно
<BR>выполнить операцию git checkout соответствующей локальной ветки (если другая
<BR>задача на ветке), или же операции git pull; git stash apply (если другая
<BR>задача на stash)</P>

<P>Если кому-то ну очень не хочется работать в терминах задач, как я тут
<BR>расписал, а хочется "тесного взаимодействия" с удалённым репозиторием, то
<BR>этого можно достичь так:</P>

<P>- ограничиться работой только на локальной ветке master,
<BR>- перед каждым commit делать pull и разрешать конфликты [это фактически
<BR>  извращённая форма rebase, когда локальных коммитов нет, а рабочий каталог
<BR>  грязный],
<BR>- после каждого commit делать push</P>

<P>Но при этом теряется как минимум описанная выше поддержка многозадачности, а
<BR>также возможность переписывать историю (так как переписывать опубликованную
<BR>историю нежелательно).</P>

<P>Честно говоря, я не вижу рациональных причин так поступать.</P>

<P>> Команд update/revert нет.
<BR>> checkout делает явно что-то "другое"</P>

<P>См. 'git-svn crash course, <A HREF="http://git.or.cz/course/svn.html">http://git.or.cz/course/svn.html</A>'
<BR>Это простая сводная таблица команд svn и их аналогов в git.</P>

<P>> 1. Захожу в каталог своего модуля (.../src/XXX/)
<BR>>     (в случае, если ночевал в чужом каталоге).
<BR>> 2. Делаю команду svn status или svn status -rHEAD.
<BR>>     (этот шаг делается если "давно не был" или забыл, есть
<BR>>      ли несохраненные изменения).
<BR>> 2'. Если trunc для моего модуля "ушёл", смотрю svn log/svn diff.
<BR>> 3. Делаю svn up. В случае конфликтов разрешаю их.
<BR>>
<BR>> ...
<BR>>
<BR>> Например, что (и когда) я должен делать _вместо_ шагов 1.-3. ?</P>

<P>Мне кажется, расписанный выше workflow содержит исчерпывающий ответ на этот
<BR>вопрос? Если нет, то что именно непонятно?</P>

<P>> Что я должен делать вместо revert ?</P>

<P>git checkout path/to/file</P>

<P>> Например, git status/diff/commit без аргументов "действуют" не на
<BR>> текущий модуль, а на весь Проект  . В некоторых случаях флаг --force
<BR>> существенно изменяет логику операциию.</P>

<P>Команда status описывает состояние всего рабочего каталога - такова
<BR>её семантика. Это не должно как-либо мешать в "ориентированном на задачи"
<BR>workflow.</P>

<P>Команда commit без аргументов создаёт коммит из текущего содержимого git
<BR>index, куда изменения заносятся командой git add.
<BR>Команда commit -a перед выполнением коммита заносит в git index все изменения
<BR>рабочего каталога. Использовать её надо с осторожностью.</P>

<P>Я лично всегда перед коммитом - даже временным/локальным - делаю git status,
<BR>чтобы понять, что произойдёт. Если это не соответствует моим пожеланиям, я
<BR>выполняю команды, которые тот же git status показывавет в качестве подсказки.</P>

<P>git diff по умолчанию действительно действует на весь рабочий каталог. Но
<BR>опять же, в "ориентированном на задачи" workflow он покажет тебе только
<BR>изменения, сделанные в рамках текущей задачи.</P>

<P>Флаг --force использовать не надо, если ты только не представляешь очень
<BR>хорошо, что делаешь.</P>

<P>> Добавлю, что _после_ расписывания сценария работы с транком следует
<BR>> расписать:
<BR>> 1. Сценарий разработки функциональности "в отдельной ветке"
<BR>> (в терминах CVS) с последующей заливкой на транк.</P>

<P>При использовании "ориентированного на задачи" workflow разницы практически не
<BR>будет. Пока ветка локальная - так вообще не будет.</P>

<P>Если по любой причине необходимо или хочется публиковать промежуточные
<BR>результаты в удалённом репозитории, можно создать там ветку</P>

<P>git fetch origin
<BR>git branch my_cool_branch origin/master
<BR>git push origin my_cool_branch:my_cool_branch
<BR>git branch -D my_cool_branch</P>

<P>после чего использовать в описанном workflow ветку origin/my_cool_branch в
<BR>качестве базы.</P>

<P>Дальнейшее слияние может быть через rebase или через merge.</P>

<P>Rebase делается примерно так (предполагаю, что в локальном репозитории ветка
<BR>my_cool_branch уже есть):</P>

<P>git fetch origin
<BR>git checkout my_cool_branch
<BR>git rebase origin/master</P>

<P>В результате в локальном репозитории ветка my_cool_branch будет заменена
<BR>на новую, построенную относительно текущего положения origin/master</P>

<P>Далее возможны два варианта:</P>

<P>git push origin my_cool_branch:master</P>

<P>Это разместит всю историю my_cool_branch поверх текущего положения master,
<BR>причём указатель ветки master в репозитории origin будет переставлен на
<BR>последний коммит my_cool_branch</P>

<P>git push -f origin my_cool_branch:my_cool_branch</P>

<P>Это переставит указатель ветки my_cool_branch в репозитории origin на её новое
<BR>положение. Тут используется -f, так как это по сути non-fast-forward операция.
<BR>В этом случае master в удалённом репозитории останется на месте и от него начнётся
<BR>новое "основание" ветки.</P>

<P>Если при этом с веткой my_cool_branch работали другие люди, то после этого у них
<BR>могут быть трудности. Так что если ожидается какая-либо новая работа в
<BR>my_cool_branch, то вместо rebase можно использовать merge.
<BR>(Проблемы можно устранить git reset --hard в локальном репозитории)</P>

<P>Тогда "ветвление и слияние" останется в истории ветки master, но зато
<BR>ветка my_cool_branch сможет продолжить своё развитие.</P>

<P>Когда в репозитории есть локальные ветки master и my_cool_branch, merge
<BR>делается так:</P>

<P>git checkout master
<BR>git merge my_cool_branch
<BR>git push</P>

<P>При merge возможны конфликты. Их придётся разрешить.</P>

<P>> 2. Сценарий формирования релиз-ветки. В том числе перетаскивания на неё
<BR>> отдельных коммитов (критических багфиксов итд) с транка.</P>

<P>Самое тупое - это просто создать релиз-ветку, и потом в рамках описанного выше
<BR>"ориентированного на задачи" workflow работать с этой веткой как с базой.</P>

<P>В частности, "перетаскивание коммита" - это выполнение операции
<BR>git cherry-pick в том месте workflow, где сказано "решать задачу".</P>

<P>> Также не лишне было бы понять, как _автоматически_ поддерживать в gitk
<BR>> отображение _текущего_ состояния репозитория. Делать каждый раз (а)
<BR>> обновление текущего клона репозитория и (б) нажатие каких-то кнопок в
<BR>> gitk -- очень напряжно.</P>

<P>gitk всегда показывает состояние локального репозитория.
<BR>Чтобы увидеть изменения в удалённом репозитории, сначала надо скопировать их в
<BR>локальный репозиторий командой git fetch.</P>

<P>Основной сценарий работы с gitk - запускать его, посмотреть что надо и
<BR>закрывать. У него довольно многое можно задать в командной строке (чтобы он
<BR>показал именно "что надо") - он принимает все параметры git rev-list.</P>

<P>"Долгоживущий" gitk - это нестандартный сценарий. Под это он не оптимизирован.
<BR>Хотя команда refresh в меню у него есть.
<BR></CODE></P>
</BODY>
</HTML>