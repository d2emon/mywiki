<!DOCTYPE html>
<HTML>
<HEAD>
	<META HTTP-EQUIV='CONTENT-TYPE' CONTENT='TEXT/HTML; CHARSET=UTF-8'/>

	<STYLE type="text/css">
		body, div, p, table {
			font-size:10pt;
			font-family:Verdana;
		}

		img{border:none}
		
	</STYLE>
	
</HEAD>

<BODY>
<P>
<H1>Ежедневный Git</H1></P>

<P>Уже были статьи про основы гита (0, 1, 2), были и статьи про внутреннее устройство репозитория. Сегодня поговорим, как простому смертному работать с гитом на автопилоте и не морочить себе голову.</P>

<P>Во-первых, шорткаты (в порядке убывания популярности):</P>

<P><CODE>
<BR>alias gst='git-status' 
<BR>alias ga='git-add'
<BR>alias gc='git-commit -m'
<BR>alias gp='git pull && git push'
<BR>alias gull='git pull'
<BR>alias gush='git push'
<BR>alias gb='git-branch'
<BR>alias gco='git-checkout'
<BR>alias gd='git-diff'
<BR></CODE></P>

<P>Во-вторых, отображение текущей ветки в командной строке:</P>

<P><CODE>
<BR>export PS1='`__git_ps1 "%s"` \w \$ '
<BR></CODE></P>

<P>Выглядит так: </P>

<P><CODE>
<BR>lazy-args-in-futures ~/Work/io/oleganza-io.git $
<BR></CODE></P>

<P>
<H2>Типичный поток работы в одной ветке</H2></P>

<P>
<OL>
<LI>Что-то пописали, прогнали тесты</LI>
<LI>$ gst — увидели, какие файлы новые, какие обновленные.</LI>
<LI>$ ga a b c — добавили новые и обновленные файлы в индекс.</LI>
<LI>$ gc 'something is done' — записали коммит в репозиторий</LI>
<LI>Снова что-то написали, снова закоммитили.</LI>
<LI>$ gp — слили чужие изменения, залили свои изменения. Если вдруг возник конфликт, вам об этом напишут, будете мерджить.</LI>
</OL>Чтобы просто подтянуть обновления, набираем $ gull (git pull).</P>

<P>
<H2>Локальные ветки</H2></P>

<P>Принцип: одна фича — одна ветка. Один багфикс (если предполагается длиннее двух коммитов) — одна ветка. Один эксперимент — одна ветка. Одна фича внутри эксперимента — ветка от ветки. Ну, вы уловили идею.</P>

<P>Зачем оно нужно? Представьте, что вы начали день с фичи А, а к вам подошли и сказали, что нужно зафиксить Б. А через пять минут выяснилось, что для того, чтобы по-человечески зафиксить Б, нужно прикрутить и проверить Ц. Если каждую из этих задач держать в отдельных ветках, то голова не пойдет кругом, и работа не встанет поперек горла. </P>

<P>Набираем:
<BR><CODE>
<BR>master ~/project $ gco -b my-feature
<BR></CODE></P>

<P>Получаем:
<BR><CODE>
<BR>my-feature ~/project $ 
<BR></CODE></P>

<P>Список всех веток: $ gb</P>

<P>Переключиться на другую ветку: $ gco some-branch</P>

<P>Не забывайте, что вы всегда можете подлить какую-нибудь ветку в текущую с помощью git merge other-branch.</P>

<P>
<H2>Жизненные ситуации с ветками</H2></P>

<P>
<UL>
<LI>Исправление бага/добавление фичи. Делаем ветку, все тестируем, подливаем в нее master: gull && git merge master, снова тестируем, выходим в мастер (gco master), подливаем ветку (git merge my-branch), тестируем, заливаем мастер (gush) и удаляем ветку (gb -D my-branch).</LI>
<LI>Публикация ветки для совместной работы: gush origin my-branch:refs/heads/my-branch
<BR>Удаление ветки: gush origin :refs/heads/my-branch (внимание на пробел перед двоеточием)</LI>
<LI>Вы сидите в одной ветке и сделали что-то, что хотели бы закоммитить в другую ветку. Если вы еще не закоммитили, то делаем git reset HEAD для уже добавленных файлов (через ga/git-add), потом git-stash, выходим в нужную ветку, делаем git-stash apply и далее действуем так, как будто мы прямо тут все и меняли.</LI>
<LI>Вы сделали коммит в некоторую экспериментальную ветку, который имеет смысл залить в мастер, но git merge my-branch не подходит, потому что после этого коммита были еще несколько экспериментальных коммитов.</LI>
</UL>На этот случай есть git-cherry-pick. Вначале, посмотрите git-log и скопируйте номер нужного коммита. Далее, вы должны закоммитить все изменения в той ветке, в которую будете кидать выдернутый коммит. Затем, делаете git-cherry-pick и разруливаете конфликты, если возникли. </P>

<P>У меня такая ситуация была именно с добавлением коммита в мастер, поэтому после этих хирургических манипуляций мне нужно было подлить мастер в локальную ветку. Поскольку cherry-pick всего лишь применяет дифф (номер коммита становится другим), то ветка не знает, что внесенное изменение у нее уже есть, и не может нормально его смерджить. Поэтому, при мердже мастера в ветку вы гарантированно получите глупые конфликты а-ля «строчка АБВ конфликтует с АБВ». </P>

<P>Если кто-нибудь знает, как избежать конфликтов в такой ситуации (и сэкономить 5 минут времени), поделитесь опытом.</P>

<P>
<H2>Скучные нравоучения напоследок</H2></P>

<P>
<OL>
<LI>Коммиты должны быть мелкими. Дифф на пять экранов должен быть исключением, а не правилом.</LI>
<LI>На первых порах не морочьте себе голову с rebase и «чистотой» линии коммитов. Это беспокоит только последних эстетов или Линуса (который мерджит десяток веток в день). Читать git-log и игнорировать банальные merge commits нет никакой проблемы.</LI>
<LI>Читайте git-log после pull, ругайте своих коллег за невразумительные описания коммитов.</LI>
<LI>Изучите .git/config :-)</LI>
</OL>В следующий раз нужно написать пару слов о комфортной работе с git-submodule и git-svn.</P>
</BODY>
</HTML>