<!DOCTYPE html>
<HTML>
<HEAD>
	<META HTTP-EQUIV='CONTENT-TYPE' CONTENT='TEXT/HTML; CHARSET=UTF-8'/>

	<STYLE type="text/css">
		body, div, p, table {
			font-size:10pt;
			font-family:Verdana;
		}

		img{border:none}
		
	</STYLE>
	
</HEAD>

<BODY>
<P>
<H1>Git</H1></P>

<P>Система контроля версий</P>

<P><A HREF="Git на двоих">Git на двоих</A>
<BR><A HREF="Всё, что нужно знать про Git">Всё, что нужно знать про Git</A>
<BR><A HREF="Ежедневный Git">Ежедневный Git</A>
<BR><A HREF="Еще немножко про git">Еще немножко про git</A></P>

<P>Год назад мы с командой решили перейти с SVN на Git. Зачем это было надо — писать не буду, т.к. на эту тему уже и так много написано. А хочу я описать типичные алгоритмы работы, понятные человеку, который долгое время пользовался SVN. Ниже — памятка, написанная для команды год назад, чтобы легче было мигрировать. Надеюсь, кому-нибудь пригодится. </P>

<P>
<H2>Немного об устройстве Git (упрощённо).</H2></P>

<P>Git — распределённая VCS. Это значит, что мы работаем не с одним репозитарием на сервере, а каждый имеет у себя локальную копию репозитария. Соответственно, такие операции, как checkout и commit производятся с локальным репозитарием. Друг с другом же (или с тем, что на сервере) репозитарии синхронизируются специально предназначенными командами pull (fetch) и push.</P>

<P>Это удобно. Это позволяет коммитить столь часто, сколь угодно, даже если в данный момент отсутствует соединение с сервером.</P>

<P>Важное преимущество Git'а — внятная работа с ветками и удобный механизм слияний (merge). В SVN мы, как правило, работали с одной веткой trunk (в git ветка, с которой мы работаем по умолчанию, называется master). Эта же ветка заливалась на продакшн. Главное неудобство здесь — то, что если мы производим какие-то изменения, или разрабатываем новый функционал, мы вынуждены либо сидеть и не коммитить до тех пор, пока задача не будет доделана до конца, либо (если нам нужна помощь коллеги), закоммитить недоделанный функционал, как есть, сделав таким образом trunk непригодным к заливке на продакшн. Особенно это неприятно, если новый функционал делается не один день, а в это время возникает необходимость что-нибудь срочно починить в рабочей системе.</P>

<P>Надо отметить, что в SVN, конечно, есть ветки, но сделаны они, видимо, для другого, и поэтому плохо приспособлены для того, чтобы их сливать в trunk. В git операция merge сделана изящно и удобно, что позволяет нам существенно изменить workflow на более оптимальный.</P>

<P>Ещё одно отличие git в том, что он хранит не изменения, а текущее состояние проекта в каждый момент времени.</P>

<P>
<H2>О главном.</H2></P>

<P>
<UL>
<LI>master — это та ветка, которая всегда, в любой (!) момент должна быть готова к деплою на продакшн.</LI>
<LI>Поэтому мы никогда не делаем новые фичи и багфиксы сразу в master, используем для этого ветки.</LI>
<LI>Полезно будет изучить статьи 1 2 3 4 и, возможно, даже Git book. В статье №2 oleganza  сформулировал очень важный принцип: одна фича — одна ветка. Один багфикс (если предполагается длиннее двух коммитов) — одна ветка. Один эксперимент — одна ветка. Одна фича внутри эксперимента — ветка от ветки.</LI>
<LI>Всегда пишем вразумительные комментарии к коммитам.</LI>
<LI>После того, как фича (багфикс) написаны, оттестированы и готовы к продакшну, мержим ветку в master.</LI>
</UL>Когда мы можем коммитить прямо в master? Только тогда, когда мы точно уверены в том, что наше мелкое изменение однозначно решит проблему и не создаст новых. Когда уверены, что не понадобится потом делать bugfix для bugfix'а. При этом, изменения должны быть минимальными.</P>

<P>Поэтому, хорошим правилом будет, всё же, создание отдельной ветки (за исключением совсем уж простых случаев).</P>

<P>
<H2>Настройка.</H2></P>

<P><CODE>
<BR>$ git config --global user.name «First Last»
<BR>$ git config --global user.email «email@example.com»
<BR>$ git config --global color.diff «auto»
<BR>$ git config --global color.status «auto»
<BR>$ git config --global color.branch «auto»
<BR></CODE></P>

<P>Дополнительно можно настроить shell-alias'ы, как описано в статье №2.</P>

<P>
<H2>Cтандартный workflow.</H2></P>

<P>
<H3>Шаг 1. Начало работы — клонирование репозитария.</H3></P>

<P>Предполагается, что у вас уже есть и настроен gitosis, на котором лежит проект.</P>

<P><CODE>  git clone gitosis@git.yourserver.com:yourproject.git </CODE> — этот шаг делается один раз.</P>

<P>Результатом будет папка yourproject с проектом у вас на жёстком диске. Команда clone делает следующие вещи: клонирует удалённый репозитарий в новую папку (yourproject в данном случае), создаёт в локальном репозитарии remote-tracking ветки для всех веток удалённого репозитария, создаёт локальную копию активной в данный момент удалённой ветки и делает из неё checkout.</P>

<P>
<H3>Шаг 2а. Написание нового кода или багфикс.</H3></P>

<P>1. git branch — смотрим, какие ветки у нас есть в данный момент в репозитарии. Сразу после клонирования у вас будет видна только одна, активная в данный момент в удалённом репозитарии, ветка (в нашем случае это по умолчанию master, т.к. удалённый репозитарий находится на сервере и в нём ветки никто не переключает). Если в репозитарии есть другие ветки, их можно увидеть, добавив ключ -a (активная ветка обозначена звёздочкой):</P>

<P><CODE>
<BR>$ git branch -a
<BR>
<UL>
<LI>master</LI>
</UL>origin/HEAD
<BR>origin/master
<BR>origin/feature
<BR></CODE></P>

<P>2. Допустим, мы хотим заимплементить фичу feature. Создаём локально новую ветку с помощью команды branch. Командой checkout можно переключаться между ветками: </P>

<P><CODE>
<BR>$ git branch feature
<BR>$ git checkout feature
<BR>Switched to branch "feature"
<BR></CODE></P>

<P>Или, что тоже самое, только короче:</P>

<P><CODE>
<BR>$ git checkout -b feature
<BR>Switched to a new branch "feature"
<BR></CODE></P>

<P>3. В git есть такое понятие как индекс. Например, команда commit добавляет в репозитарий только те файлы, которые есть в данный момент в индексе. Поэтому, во время работы не забываем добавлять (git add ) или удалять (git rm ) файлы в/из индекса репозитария. Обратите внимание, что, в отличие от SVN, если вы изменили файл, его заново нужно добавить в индекс командой git add.</P>

<P>Например:</P>

<P><CODE>
<BR>$ git add file1 file2
<BR>$ $ git commit -m "adding file1 & file2"
<BR>Created initial commit 8985f44: adding file1 & file2
<BR>2 files changed, 2 insertions(+), 0 deletions(-)
<BR>create mode 100644 file1
<BR>create mode 100644 file2
<BR></CODE></P>

<P>Здесь есть полезности: команда git add . добавляет все untracked файлы в индекс (рекурсивно), а ключ -a у команды commit позволяет автоматически добавить все модифицированные (но не новые!) файлы.</P>

<P>Текущее состояние индекса можно посмотреть командой git status:</P>

<P><CODE>
<BR>$ git status
<BR>
<OL>
<LI>On branch feature</LI>
<LI>Changes to be committed:</LI>
<LI>(use "git reset HEAD <file>..." to unstage)</LI>
<LI></LI>
<LI>new file: file1</LI>
<LI>new file: file2</LI>
<LI></LI>
</OL></CODE></P>

<P>Коммиты в репозитарии смотрятся командой git log.</P>

<P>4. Если мы хотим разрабатывать новый функционал совместно, нам нужно опубликовать нашу ветку на сервере, чтобы другие могли с ней работать. Вот как это делается (перед этим необходимо закоммитить все изменения в данной ветке):</P>

<P><CODE>
<BR>$ git push origin feature:refs/heads/feature
<BR>Counting objects: 4, done.
<BR>Compressing objects: 100% (2/2), done.
<BR>Writing objects: 100% (3/3), 273 bytes, done.
<BR>Total 3 (delta 0), reused 0 (delta 0)
<BR>Unpacking objects: 100% (3/3), done.
<BR>To gitosis@git.yourserver.com:yourproject.git
<BR>
<UL>
<LI>[new branch] feature -> feature</LI>
</UL></CODE></P>

<P>(в новых версиях git можно просто git push origin feature:feature)</P>

<P>Команда push отправляет изменения в удалённый репозитарий (origin) из локальной ветки feature в удалённую ветку featurе, предварительно создав её там (refs/heads/feature нужно как раз для создания ветки). В дальнейшем можно будет использовать git push origin feature (по умолчанию git push публикует изменения из всех веток).</P>

<P>Но при таком способе публикации, не устанавливается связь между локальной версией ветки и опубликованной. Т.е. если кто-то закоммитит изменения в эту удаленную ветку и вы сделаете git pull, то будет ошибка:</P>

<P><CODE>
<BR>$ git pull
<BR>remote: Counting objects: 3, done.
<BR>remote: Compressing objects: 100% (2/2), done.
<BR>remote: Total 2 (delta 1), reused 0 (delta 0)
<BR>Unpacking objects: 100% (2/2), done.
<BR>From gitosis@git.yourproject.com:yourproject
<BR>d23a39c..b0a86e0 feature -> origin/feature
<BR>You asked me to pull without telling me which branch you
<BR>want to merge with, and 'branch.feature.merge' in
<BR>your configuration file does not tell me either. Please
<BR>name which branch you want to merge on the command line and
<BR>try again (e.g. 'git pull <repository> <refspec>').
<BR>See git-pull(1) for details on the refspec.</P>

<P>If you often merge with the same branch, you may want to
<BR>configure the following variables in your configuration
<BR>file:</P>

<P>branch.feature.remote = <nickname>
<BR>branch.feature.merge = <remote-ref>
<BR>remote.<nickname>.url = <url>
<BR>remote.<nickname>.fetch = <refspec></P>

<P>See git-config(1) for details.
<BR></CODE></P>

<P>Т.е. гит не знает с какой ветки ему мерджить. Поэтому можно либо каждый раз указывать это руками:</P>

<P><CODE>
<BR>git pull origin feature
<BR></CODE></P>

<P>Либо прописать в конфиге:</P>

<P><CODE>
<BR>git config branch.feature.remote origin
<BR>git config branch.feature.merge refs/heads/feature
<BR></CODE></P>

<P>Кроме того можно воспользоваться скриптиком от William Morgan и делать git publish-branch feature вместо всего остального.</P>

<P>
<H3>Шаг 2б. Как присоединиться к работе над веткой.</H3></P>

<P>Предполагается, что вы уже склонировали себе репозитарий.</P>

<P>Главное здесь — правильно подключить удалённую ветку. Сделать это можно с помощью ключа --track команды git checkout. Команда, приведённая ниже, создаёт локальную ветку feature и подключает её к удалённой ветке origin/feature, после чего переключается в эту ветку.</P>

<P><CODE>
<BR>$ git checkout --track -b feature origin/feature
<BR>Branch feature set up to track remote branch refs/remotes/origin/feature.
<BR>Switched to a new branch "feature"
<BR></CODE></P>

<P>Это важно на данном этапе, поскольку просто команда pull смержит удалённую ветку к нам в master, а это не то, что нам нужно.</P>

<P>Далее можно работать аналогично описанному в шаге 2а, синхронизируя репозитарий в каждой из веток командами git pull и git push.</P>

<P>
<H3>Шаг 2в. Как переключиться в другую ветку, когда в текущей есть изменения и коммитить их рано.</H3></P>

<P>Иногда возникает необходимость срочно переключиться в другую ветку, например для багфикса. Но на полноценный коммит в этой ветке еще не хватает. Для этого существует команда git stash:</P>

<P><CODE>
<BR>$ git status
<BR>
<OL>
<LI>On branch feature</LI>
<LI>Changes to be committed:</LI>
<LI>(use "git reset HEAD <file>..." to unstage)</LI>
<LI></LI>
<LI>new file: somefile</LI>
<LI></LI>
</OL>$ git stash
<BR>Saved working directory and index state "WIP on feature: b0a86e0... blabla"
<BR>HEAD is now at b0a86e0 blabla
<BR>(To restore them type "git stash apply")
<BR>$ git status
<BR>
<OL>
<LI>On branch feature</LI>
</OL>nothing to commit (working directory clean)
<BR></CODE></P>

<P>Теперь можно смело переключаться в другую ветку и работать там.</P>

<P>По возвращению в эту ветку, необходимо сделать git stash apply:</P>

<P><CODE>
<BR>$ git stash apply
<BR>
<OL>
<LI>On branch feature</LI>
<LI>Changes to be committed:</LI>
<LI>(use "git reset HEAD <file>..." to unstage)</LI>
<LI></LI>
<LI>new file: somefile</LI>
<LI></LI>
</OL></CODE></P>

<P>
<H3>Шаг 3. merge и rebase.</H3></P>

<P>Использовать какую-либо из этих команд вам понадобится в 2-х случаях:</P>

<P>
<OL>
<LI>Вы хотите подлить свежие изменения из master к себе в ветку;</LI>
<LI>Вы хотите слить свою ветку в master.</LI>
</OL>Общее правило такое: если мы работаем с веткой самостоятельно и не планируем публиковать её на сервере — то выгоднее использовать rebase. Если же мы публикуем ветку командой push, то использовать rebase НЕЛЬЗЯ, иначе мы автоматически инвалидируем работу коллег. Разница между merge и rebase хорошо показана на иллюстрациях в Git book: merge и rebase. Вкратце: rebase запоминает коммиты из ветки в виде патчей, «перематывает» текущую ветку (как будто и не было никакого branch) и применяет патчи, оформляя их в виде коммитов. В отличие от rebase, merge делает слияние двух веток в одну.</P>

<P>Примеры:</P>

<P>Подливаем изменения из master в рабочую ветку feature, ветку feature нигде не публикуем, работаем с ней только локально:</P>

<P><CODE>
<BR>$ git checkout feature
<BR>Switched to branch "feature"
<BR>$ git rebase master
<BR>First, rewinding head to replay your work on top of it...
<BR>HEAD is now at 89f6a20 file2
<BR>Applying feature1
<BR></CODE></P>

<P>Сливаем изменения из рабочей ветки feature в master, ветка feature нигде не публиковалась, никто из коллег с ней не работал:</P>

<P><CODE>
<BR>$ git checkout master
<BR>Switched to branch "master"
<BR>$ git rebase feature
<BR>First, rewinding head to replay your work on top of it...
<BR>HEAD is now at 9bfac0a feature1
<BR>Applying file2
<BR></CODE></P>

<P>Подливаем изменения из master в рабочую ветку feature, ветка feature опубликована на удалённом репозитарии, с ней также работают коллеги:</P>

<P><CODE>
<BR>$ git checkout feature
<BR>Switched to branch "feature"
<BR>$ git merge master
<BR>Merge made by recursive.
<BR>file2 | 1 +
<BR>1 files changed, 1 insertions(+), 0 deletions(-)
<BR>create mode 100644 file2
<BR></CODE></P>

<P>Сливаем изменения из рабочей ветки feature в master, ветка feature публиковалась на удалённом репозитарии для совместной работы:</P>

<P><CODE>
<BR>$ git checkout master
<BR>Switched to branch "master"
<BR>$ git merge feature
<BR>Merge made by recursive.
<BR>feature1 | 1 +
<BR>1 files changed, 1 insertions(+), 0 deletions(-)
<BR>create mode 100644 feature1
<BR></CODE></P>

<P>
<H3>Шаг 4. Удаление ветки.</H3></P>

<P>После того, как мы закончили работать с веткой и слили изменения в master (или в другую ветку), можно удалить ветку.</P>

<P>Для удаления локальной ветки:</P>

<P><CODE>
<BR>$ git branch -d feature
<BR>Deleted branch feature.
<BR></CODE></P>

<P>Для удаления remote tracking ветки:</P>

<P><CODE>
<BR>$ git push origin :feature
<BR>- [deleted] feature
<BR></CODE></P>

<P>Вот, вроде, и всё. Этого должно быть достаточно в первое время при миграции с SVN на Git.</P>

<P>Отдельное спасибо хабраюзеру mironov_anton  за всяческие дополнения и улучшения данного текста.</P>
</BODY>
</HTML>