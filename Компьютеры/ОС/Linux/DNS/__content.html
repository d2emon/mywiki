<!DOCTYPE html>
<HTML>
<HEAD>
	<META HTTP-EQUIV='CONTENT-TYPE' CONTENT='TEXT/HTML; CHARSET=UTF-8'/>

	<STYLE type="text/css">
		body, div, p, table {
			font-size:10pt;
			font-family:Verdana;
		}

		img{border:none}
		
	</STYLE>
	
</HEAD>

<BODY>
<P>
<H1>DNS</H1></P>

<P>Значение службы DNS многие не учитывают, фактически, эта служба является краеугольным камнем в работе сети интернет в целом и локальных сетей в частности, мы в свою очередь, будем оперировать менее глобальными масштабами и настроем данную службу в нашей локальной сети.</P>

<P>Идея проста, мы настроим разрешение имен внутри локальной сети, а в случае обращения к сайтам в сети интернет, то запросы будут передаваться вышестоящим DNS серверам, для разрешения имен сайтов. </P>

<P>Я не буду рассказывать назначение данной службы, о том как она работает можно прочитать в Википедии. Скажу только что эта служба иерархическая.</P>

<P>Как я писал раньше, у нас есть сервер который мы будем обвешивать функционалом, я уже рассказал как настроить его в качестве шлюза и о том как настроить работу службы DHCP, для раздачи IP адресов клиентам в локальной сети. В этот раз я расскажу о том как настроить на нем сервер DNS, ранее я уже писал, о том как настроить кеширующий DNS сервер для локальной сети, но было это уже довольно давно и я решил обновить статью, за одно добавив в нее, немного функционала.</P>

<P>Как всегда напоминаю что, данный функционал заводить на шлюзе не обязательно, все будет работать и так, но если добавить, то все должно работать, намного лучше, хотя с точки зрения конечного пользователя, разница будет не заметна.</P>

<P>Дополнительным плюсом это будет автоматическое создание прямой и обратной DNS зоны, для клиентских устройств локальной сети. Аналогичный процесс используется в сетях под управлением MS Windows в среде Active Directory. Там службы DNS и DHCP тесно интегрированы между собой т.е клиентский ПК подключившись к сети и получивший IP адрес автоматически получает DNS запись вида hostname.domainname.tld это добавляет удобства в случае необходимости подключения по имени а не по IP-который дтуднее запомнить, дополнительным плюсом является создание обратной зоны которая позволяет проводить обратный процесс -разрешение имени по IP, что может быть полезно в случае поиска устройсва если известен его IP адрес, то узнав его имя можно сразу понять о ком идет речь.</P>

<P>Собственно, подобную схему мы и реализуем, основной идеей всего этого будет полная автоматизация данного процесса для IT специалиста т.к. DHCP сервер будет создавать прямую и обратную зоны-автоматически.</P>

<P>Предполагается что:</P>

<P>
<OL>
<LI>Операционная система Ubuntu 12.04 установлена, хотя на Debian будет также работать ничуть не хуже.</LI>
<LI>Сервер настроен в качестве шлюза по статье: Настройка шлюза локальной сети, на базе Ubuntu 12.04</LI>
<LI>Также на указанном сервере настроена служба DHCP по статье: Настройка DHCP сервера под управлением Ubuntu 12.04</LI>
</OL>Первым делом, нам необходимо удалить пакет dnsmasq — который был установлен по статье, Настройка шлюза локальной сети, т.к надобность в нем отпадает, вместо него у нас будет использоваться Bind9.</P>

<P>Поднимаем права до root:
<BR><CODE>
<BR>sudo su</P>

<P>aptitude purge dnsmasq
<BR></CODE></P>

<P>Установка DNS сервера</P>

<P>Установим Bind:
<BR><CODE>
<BR>aptitude install bind9
<BR></CODE></P>

<P>Теперь генерируем ключ, для обновления DNS записей:
<BR><CODE>
<BR>dnssec-keygen -a HMAC-MD5 -b 128 -r /dev/urandom -n USER DHCP_UPDATER
<BR></CODE></P>

<P>Проверим что у нас получилось:
<BR><CODE>
<BR>cat Kdhcp_updater.*.private|grep Key
<BR></CODE></P>

<P>Нам выдаст нечто подобное (у вас ключ получится другим)
<BR><CODE>
<BR>Key: cYqlx8g/jLcIxXFDpqrxZw==
<BR></CODE></P>

<P>Его нам необходимо записать, т.к. он нам еще пригодится.</P>

<P>Переходим к настройкам Bind9, для начала отредактируем файл name.conf.option:
<BR><CODE>
<BR>nano /etc/bind/named.conf.options
<BR></CODE></P>

<P>Туда добавляем следующие строки: 
<BR><CODE>
<BR>forwarders {
<BR>        <A HREF="http://8.8.8.8">8.8.8.8</A>;
<BR>     };</P>

<P>    listen-on {
<BR>      <A HREF="http://127.0.0.1">127.0.0.1</A>;
<BR>      <A HREF="http://192.168.10.1">192.168.10.1</A>;
<BR>    };
<BR></CODE></P>

<P>Рассмотрим более подробно то что мы написали:</P>

<P>В пункте forwarders мы указали, вышестоящие DNS сервера, куда будет передаваться запрос в случае если информации о запрошенном URL не будет найдено в собственной базе, в нашем случае, это DNS сервер google, но можно указать те которые нужны вам, например DNS сервер вашего провайдера.</P>

<P>В пункте listen-on указываем IP адреса, которые будет обслуживать наш DNS сервер, это localhost и интерфейс по которому подключена наша локальная сеть <A HREF="http://192.168.10.1">192.168.10.1</A>, запросы на другие IP адреса обслуживаться не будут, эту функцию можно рассматривать как дополнительную возможность по снижению нагрузки на наш сервер т.к. запросы из вне-не обслуживаются.</P>

<P>Переходим к редактированию файла name.conf.local:
<BR><CODE>
<BR>nano /etc/bind/named.conf.local
<BR></CODE></P>

<P>Добавми туда следующее:
<BR><CODE>
<BR>key DHCP_UPDATER {
<BR>        algorithm HMAC-MD5.SIG-ALG.REG.INT;
<BR>        secret "cYqlx8g/jLcIxXFDpqrxZw==";
<BR>};
<BR> 
<BR>zone "example.net" IN {
<BR>        type master;
<BR>        file "/var/lib/bind/forward.db";
<BR>        allow-update { key DHCP_UPDATER; };
<BR>};
<BR> 
<BR>zone "10.168.192.in-addr.arpa" IN {
<BR>        type master;
<BR>        file "/var/lib/bind/reverse.db";
<BR>        allow-update { key DHCP_UPDATER; };
<BR>};
<BR></CODE></P>

<P>Рассмотрим написанное, более подробно:</P>

<P>Пункт key DHCP_UPDATER содержит информацию о ключе, который мы генерировали в самом начале.</P>

<P>Пункт zone «example.net»-зона, которую обслуживает наш DNS сервер, в нашем случае example.net (многие советуют использовать зону .local, я этого делать не рекомендую т.к. avahi daemon с данными зонами не работает, да и Microsoft также крайне не рекомендует использовать зону local, в своей, свежей, документации к Windows 2k8 )</P>

<P>Также там описывается тип зоны- master и путь к файлу где будут храниться данные зоны, последний пункт разрешает обновление данного файла, только с использованием ключа. </P>

<P>Пункт zone «10.168.192.in-addr.arpa» отвечает за создание зоны обратного просмотра, назначение остальных пунктов, думаю, вы уже поняли.</P>

<P>Теперь нам необходимо создать сами файлы, в которых будут храниться данные зоны example.net.</P>

<P>Они будут располагаться в /var/lib/bind/ сделано это по одной постой причине-группа bind не имеет права на запись в /etc/bind/, а начинать менять права на системные директории, не очень хорошая идея.</P>

<P>Переходим с созданию файла настроек зоны, для начала, создадим зону прямого просмотра назовем его forward.db:
<BR><CODE>
<BR>nano /var/lib/bind/forward.db
<BR></CODE></P>

<P>С содержимым:
<BR><CODE>
<BR>$TTL 86400      ;       1 day
<BR>example.net.    IN      SOA     srv01.example.net. admin.example.net. (
<BR>                                20110103        ; Serial
<BR>                                10800           ; Refresh
<BR>                                3600            ; Retry
<BR>                                604800          ; Expire
<BR>                                86400           ; Minimum TTL
<BR>                        )</P>

<P>                IN      NS      srv01.example.net.
<BR>                IN      A       <A HREF="http://192.168.10.1">192.168.10.1</A>
<BR>localhost       IN      A       <A HREF="http://127.0.0.1">127.0.0.1</A>
<BR>srv01           IN      A       <A HREF="http://192.168.10.1">192.168.10.1</A>
<BR></CODE></P>

<P>Из содержимого понятно что наша зона example.net, в которой присутствует DNS сервер (он же шлюз) с именем srv01, который имеет IP адрес <A HREF="http://192.168.10.1">192.168.10.1</A>. Других записей делать не будем т.к. их будет добавлять DHCP сервер автоматически.</P>

<P>Если вдруг вам понадобится создать запись в ручную, то достаточно добавить строку с именем и IP адресом узла локальной сети.</P>

<P>Теперь создадим файл зоны обратного просмотра, чтобы не выдумывать ничего, назовем его reverse.db
<BR><CODE>
<BR>nano /var/lib/bind/reverse.db
<BR></CODE></P>

<P>С содержимым:
<BR><CODE>
<BR>$TTL 86400      ;       1 day
<BR>10.168.192.in-addr.arpa. IN SOA srv01.example.net. admin.example.net. (
<BR>                        20110104        ; Serial
<BR>                        10800           ; Refresh
<BR>                        3600            ; Retry
<BR>                        604800          ; Expire
<BR>                        3600 )          ; Minimum</P>

<P>        IN      NS      srv01.example.net.
<BR>1       IN      PTR     example.net.
<BR>1       IN      PTR     srv01.example.net.
<BR></CODE></P>

<P>Выходим и перезапускам bind
<BR><CODE>
<BR>/etc/init.d/bind9 restart
<BR></CODE></P>

<P>Теперь нам необходимо проверь работоспособность нашего сервера локально.</P>

<P>Проблема заключается в том что наш сервер по умолчанию использует DNS настройки которого по получил по сети и соответственно он ничего не знает о локальном DNS сервере, которые крутится на нем же-это нам необходимо исправить.</P>

<P>Если мы полезем, править resolv.conf то в Ubuntu 12.04 нас поджидает большой сюрприз в виде надписи:
<BR><CODE>
<BR>
<OL>
<LI>Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)</LI>
<LI>DO NOT EDIT THIS FILE BY HAND — YOUR CHANGES WILL BE OVERWRITTEN</LI>
</OL></CODE></P>

<P>Которая говорит нам о том что: resolv.conf нельзя редактировать и что он создается динамически, а все внесенные в него изменения будут перезаписаны!</P>

<P>В общем его править нельзя, мы будем править сам шаблон этого файла, который находится в /etc/resolvconf/resolv.conf.d/ нас интересует файл head, вот его мы и будем править:
<BR><CODE>
<BR>nano /etc/resolvconf/resolv.conf.d/head
<BR></CODE></P>

<P>Добавляем в него:
<BR><CODE>
<BR>domain example.net
<BR>search example.net
<BR>nameserver <A HREF="http://127.0.0.1">127.0.0.1</A>
<BR></CODE></P>

<P>Более опытные уже догадались что это ничто иное как DNS суффикс и домен для поиска по умолчанию, а также IP адрес локального DNS сервера.</P>

<P>У данной схемы есть еще одно преимущество- если настройки сети получаются нашим шлюзом от DHCP сервера провайдера, то DNS сервер провайдера добавляется в конце списка, после строки nameserver <A HREF="http://127.0.0.1">127.0.0.1</A>, таким образом, наш локальный DNS всегда является приоритетным, а в случае выхода его из строя, запросы начинают идти к DNS провайдера, автоматически!</P>

<P>Перезапустим сеть:
<BR><CODE>
<BR>/etc/init.d/networking restart
<BR></CODE></P>

<P>Пробуем определить наш DNS сервер:
<BR><CODE>
<BR>dig srv01
<BR></CODE></P>

<P>В ответ получаем нечто подобное:
<BR><CODE>
<BR>; <<>> DiG 9.8.1-P1 <<>> srv01
<BR>;; global options: +cmd
<BR>;; Got answer:
<BR>;; ->>HEADER<< — opcode: QUERY, status: NXDOMAIN, id: 56977
<BR>;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0</P>

<P>;; QUESTION SECTION:
<BR>;srv01. IN A</P>

<P>;; AUTHORITY SECTION:
<BR>. 812 IN SOA a.root-servers.net. nstld.verisign-grs.com. 2012080300 1800 900 604800 86400</P>

<P>;; Query time: 44 msec
<BR>;; SERVER: <A HREF="http://127.0.0.1">127.0.0.1</A>#53(<A HREF="http://127.0.0.1">127.0.0.1</A>)
<BR>;; WHEN: Fri Aug 3 13:28:45 2012
<BR>;; MSG SIZE rcvd: 98
<BR></CODE></P>

<P>Значит ответы присылаются, это хорошо.</P>

<P>Проверим самоопределение имени нашего сервера:
<BR><CODE>
<BR>nslookup srv01
<BR></CODE></P>

<P>В ответ получим
<BR><CODE>
<BR>Server: <A HREF="http://127.0.0.1">127.0.0.1</A>
<BR>Address: <A HREF="http://127.0.0.1">127.0.0.1</A>#53</P>

<P>Name: srv01.example.net
<BR>Address: <A HREF="http://192.168.10.1">192.168.10.1</A>
<BR></CODE></P>

<P>Эту операцию, также, можно выполнить и через host, сделав запрос вида:
<BR><CODE>
<BR>host srv01
<BR></CODE></P>

<P>Если имя преобразовано в IP значит зона прямого просмотра работает нормально.</P>

<P>Теперь проверим зону обратного просмотра:
<BR><CODE>
<BR>nslookup <A HREF="http://192.168.10.1">192.168.10.1</A>
<BR></CODE></P>

<P>Нам выдаст:
<BR><CODE>
<BR>Server: <A HREF="http://127.0.0.1">127.0.0.1</A>
<BR>Address: <A HREF="http://127.0.0.1">127.0.0.1</A>#53</P>

<P><A HREF="http://1.10.168.192">1.10.168.192</A>.in-addr.arpa name = srv01.example.net.
<BR><A HREF="http://1.10.168.192">1.10.168.192</A>.in-addr.arpa name = example.net.
<BR></CODE></P>

<P>Если ответ получен, значит обратное разрешение имен, также, работает.</P>

<P>Можно считать половину дела сделанным…</P>

<P>Настраиваем динамическое обновление зон DHCP сервером.</P>

<P>Если вы настраивали DHCP сервер, по моему руководству, ссылка на которое есть в начале этой статьи, то у вас в конфигурационном файл должна присутствовать запись:
<BR><CODE>
<BR>subnet <A HREF="http://192.168.10.0">192.168.10.0</A> netmask <A HREF="http://255.255.255.0">255.255.255.0</A> {
<BR>range <A HREF="http://192.168.10.10">192.168.10.10</A> <A HREF="http://192.168.10.254">192.168.10.254</A>;
<BR>option domain-name-servers <A HREF="http://192.168.10.1">192.168.10.1</A>;
<BR>option domain-name "example.net";
<BR>option routers <A HREF="http://192.168.10.1">192.168.10.1</A>;
<BR>option broadcast-address <A HREF="http://192.168.10.255">192.168.10.255</A>;
<BR>default-lease-time 604800;
<BR>max-lease-time 604800;
<BR>}
<BR></CODE></P>

<P>Мы ее немного подправим, а именно заменим option domain-name на example.net перед диапазоном адресов нашего DHCP сервера, добавляем следующее:
<BR><CODE>
<BR>nano /etc/dhcp/dhcpd.conf
<BR></CODE></P>

<P>За одно добавим строку update-static-leases on; которая отвечает за автоматическое создание прямой и обратной зоны для клиентов с зарезервированным IP, без нее записи придется создавать в ручную, а мы этот процесс автоматизируем.
<BR>@
<BR>ddns-update-style interim;
<BR>update-static-leases    on; 
<BR>key DHCP_UPDATER {
<BR>algorithm hmac-md5;
<BR>secret "cYqlx8g/jLcIxXFDpqrxZw==";
<BR>}
<BR> 
<BR>zone example.net. {
<BR>primary <A HREF="http://127.0.0.1">127.0.0.1</A>;
<BR>key DHCP_UPDATER;
<BR>}
<BR> 
<BR>zone 10.168.192.in-addr.arpa. {
<BR>primary <A HREF="http://127.0.0.1">127.0.0.1</A>;
<BR>key DHCP_UPDATER;
<BR>}
<BR><CODE></P>

<P>В результате всех действий, у вас должен получиться конфигурационный файл вида:
<BR></CODE>
<BR>ddns-update-style interim;
<BR>update-static-leases    on;
<BR>key DHCP_UPDATER {
<BR>algorithm hmac-md5;
<BR>secret "cYqlx8g/jLcIxXFDpqrxZw==";
<BR>}
<BR> 
<BR>zone example.net. {
<BR>primary <A HREF="http://127.0.0.1">127.0.0.1</A>;
<BR>key DHCP_UPDATER;
<BR>}
<BR> 
<BR>zone 10.168.192.in-addr.arpa. {
<BR>primary <A HREF="http://127.0.0.1">127.0.0.1</A>;
<BR>key DHCP_UPDATER;
<BR>}</P>

<P>subnet <A HREF="http://192.168.10.0">192.168.10.0</A> netmask <A HREF="http://255.255.255.0">255.255.255.0</A> {
<BR>range <A HREF="http://192.168.10.10">192.168.10.10</A> <A HREF="http://192.168.10.254">192.168.10.254</A>;
<BR>option domain-name-servers <A HREF="http://192.168.10.1">192.168.10.1</A>;
<BR>option domain-name "example.net";
<BR>option routers <A HREF="http://192.168.10.1">192.168.10.1</A>;
<BR>option broadcast-address <A HREF="http://192.168.10.255">192.168.10.255</A>;
<BR>default-lease-time 604800;
<BR>max-lease-time 604800;
<BR>}
<BR><CODE></P>

<P>Остальные настройки, оставляем как они были представлены в руководстве по настройке DHCP сервера.</P>

<P>Перезапустим DNS и DHCP сервер:
<BR></CODE>
<BR>/etc/init.d/bind9 restart
<BR>/etc/init.d/isc-dhcp-server restart
<BR><CODE></P>

<P>Подключаем наш клиентский ПК к локальной сети, предположим что его имя test01 он получит IP от нашего DHCP сервера, а DHCP сервер создаст DNS запись вида test01.example.net.</P>

<P>Пробуем выполнить запрос по имени
<BR></CODE>
<BR>nslookup test01
<BR>@@
<BR>нам должен возвращаться IP адрес который получила клиентская машина от DHCP сервера.</P>

<P>Ну и преобразование IP адреса в имя, также должно работать.</P>

<P>Во время работы данной связки, у нас будут создаваться файлы в директории /var/lib/bind с расширением .jnl, они создаются автоматически, создавать или удалять их не нужно. </P>

<P>Теперь работы по настройке данной схемы можно считать успешно завешенными.</P>

<P>На этом все.</P>

<P>Возникли предложения по улучшению или вопросы, прошу в комментарии, нашли ошибку, пишите в личку…</P>
</BODY>
</HTML>