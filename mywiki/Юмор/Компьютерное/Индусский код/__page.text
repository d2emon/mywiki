!! Индусский код

Индусский код (в среде программистов 80х также известен как Gletch) — в самом общем случае, это криво написанный код. Однако на самом деле, под индусским кодом подразумевают код, написанный наиболее неочевидным и неестественным из всех возможных способов. Именно этим он и отличается от быдлокода, который хотя бы капельку очевиден.

По другой трактовке, индусский код — жаргонное нарицательное название для программного кода крайне низкого качества, использующего простые, но порочные принципы «copy-paste», «главное завалить — а там запинаем», «шапкозакидательство». Так же известен как «write only», или (в пику принципу «написано однажды — читается везде») — «написанное однажды — лучше не читать».

!!! К.О. сообщает

Алсо аутентичный индусский код пишется на хинди и транслитерируется в C, C++ или java. По некоторым сведениям, индусский код поют и танцуют, и только потом записывают на хинди.

!!! Примеры индусского кода

!!!! Пример № 1 (C#)

@@
uint i;
...
if (i.ToString().Length == 1)
{
  ...
}
@@

Не сразу можно понять, что в этом коде просто-напросто выполняется проверка i<10. Алгоритм достаточно прост: выполняется преобразование i в строку, после чего вычисляется её длина. Если число больше 9, то его десятичная запись содержит больше одного символа. Отрицательные числа переменная типа uint содержать не может. Проверку проходят лишь числа от 0 до 9.

Алгоритм ресурсоёмок, не очевиден и не поддается сопровождению даже теоретически.

!!!! Пример № 2 (C#)

@@
double rest(float a, float b)
{float res=a*b;
for (int i=0; i<999999999; i++)
 if (i<=res && i+1>res) {res = res-i; break;}
return res;
}
@@

Далеко не сразу можно понять, что этот код выделяет дробную часть произведения a*b. кроме того, функция выдаст ошибочное значение при a*b>999999999 или a*b<0. Также зависимость времени выполнения от величины целой части тоже не радует.

!!!! Пример № 3 (C#)

@@
bool IsNumber (string str)
{
return (str.Replace ("0", "").Replace ("1", "").Replace ("2", "").Replace ("3", "").Replace ("4", "").Replace ("5", "").Replace ("6", "").Replace ("7", "").
Replace ("8", "").Replace ("9", "").Length == 0);
}
@@

Хотя в данном случае, вообще говоря, алгоритм вполне очевиден, не менее очевидно и то, что для его выполнения конструктор класса string будет вызван не менее десяти раз, (т.к. любое изменение класса String в C# приводит к созданию нового экземпляра и передачей старого экземпляра сборщику мусора) со всеми вытекающими из этого последствиями. И всё только потому, что какому-то индусу было лень придумать менее ресурсоёмкую альтернативу.

В случае множественных замен надо использовать StringBuilder.Replace(), а в данном - int.TryParse(). Не изобретайте велосипед! Кроме того, сам алгоритм кода имеет ошибку, т.к. он будет некорректно обрабатывать отрицательные числа. Добавление еще одного Replace("-","") к win не приведет, функция может вернуть труъ для строки "-"/

!!!! Пример № 4 (C#)

@@
bool value;
 
…
 
if (value.ToString().Length == 4)
{ 
  ...
}
else if (value.ToString().Length == 5)
{
  ...
}
else
{
   // внимание! кто-то хочет нас наебать подсунув некачественный (по всей вероятности, протухший) bool, но мы ему не дадим:
   throw new ArgumentException();
   // у некоторых племенных индусов бывает и продолжение, на случай если throw вдруг не сработает:
   return !true && !false;
   // надо же вернуть какую-нибудь хуйню, чтобы заказчик не ныл
}
@@

В этом примере проверка истинности значения логической переменной производится с помощью длины её текстового представления. Если длина равна четырём („True“), значение истинно, если пять („False“) - ложно, если ни то, ни се - тогда включаем panic mode и начинаем жарить карри. Правда злобный компилятор вяло ругнется ворнингом. Но какой дурак их читает?

Кроме привычной нам логики с двумя значениями (ложь и истина), существуют так же и другие логики. Примером может служить логика, основывающаяся на доказуемости теорем. Несложно заметить, что из не недоказуемости теоремы не следует ни её доказуемость, ни её недоказуемость (теорема может быть не разрешима в данной системе аксиом). Так что возможно в коде автора есть глубокий расчёт на будущее, но это вряд ли.

!!!! Пример № 5 (PHP)

@@
if ($_POST["end_oplata"]!="sending" and $_POST["continue_oplata"]!="prodoljit" and $_POST["prov"]!="proverka") { 
... 
}
elseif ($_POST["continue_oplata"]!="prodoljit" and $_POST["prov"]!="proverka") {
...
}
elseif ($_POST["continue_oplata"]=="prodoljit") {
...
}
@@

В этом примере проверяется, какое действие нужно выполнить. Вместо того, чтобы создать одну переменную со значением следующего действия, создается три «быдлокодерских» переменных.

К тому же, это пример ужасного стиля именования переменных, containing as английские слова, так и transliterated russian ones. Видимо, сказался author’s poor английский словарный запас.

!!!! Пример № 6

На этой странице есть ссылки на страницу Индус. Если перейти на эту страницу, то Вы окажетесь опять же здесь. Пожалуйста, не правьте эти ссылки — они сделаны специально для примера.

!!!! Пример № 7

TurDuckEn Code — разновидность быдлокода, чаще всего встречающаяся в веб-приложениях. Как спагетти-код, только хуже. ТурДукен — пиндосская нямка, cостоящая из индейки (turkey), нафаршированной уткой (duck), зафаршированной курицей (chicken).

Турдукен Код, например, состоит из PHP, фаршированным SQL, нафаршированным HTML, зафаршированным Javascript’ом. Вот так.

!!!! Пример № 8

Вычисление Интеграла (С++)

@@
#include <math>
 
double f(double d){
return fabs(cos(d));
}
 
double integralrect(const double& a, const double& b, const double& epsilon)
{
double result;
int i;
int n;
double h;
double s1;
double s2;
 
n = 1;
h = b-a;
s2 = h*f((a+b)/2);
do
{
n = 2*n;
s1 = s2;
h = h/2;
s2 = 0;
i = 1;
do
{
s2 = s2+f(a+h/2+h*(i-1));
i = i+1;
}
while(i<=n);
s2 = s2*h;
}
while(fabs(s2-s1)>3*epsilon);
result = s2;
return result;
}

и, собственно, нахождение самого интеграла:
 
double s=integralrect(0,M_PI,0.0001);
s++;
@@

!!!! Пример № 9

Java

@@
public void write(){
     System.out.print("(");
     if (a.getHard()!=null){
      a.write();
     }
     else if (a.getConst()!=null){
      Const t=a.getConst();
      System.out.print(t);
     }
     else if (a.getVal()!=null) {
      Val t=a.getVal();
      System.out.print(t);
     }
     System.out.print(op.getOp());
     if (b.getHard()!=null){
      b.write();
     }
     else if (b.getConst()!=null){
      Const t=b.getConst();
      System.out.print(t);
     }
     else if (b.getVal()!=null) {
      Val t=b.getVal();
      System.out.print(t);
     }
     System.out.print(")");
    }
@@

так пишут нормальные люди

@@
public void write(){
     System.out.print("(");
     a.write();
     System.out.print(op.getOp());
     b.write();
     System.out.print(")");
}
@@

!!!! Пример № 10 (SQL)

@@
SELECT CASE WHEN a>b THEN 1 ELSE NULL END
@@

"Далеко не сразу можно понять", что ELSE является избыточным в данном контексте. Оператор CASE, при отсутствии верных условий, возвращает NULL.

!!!! Пример № 11 (SQL)

@@
SELECT *
FROM table1
WHERE a>0 AND a IS NOT NULL
@@

"Не очевидно", что "a IS NOT NULL" является избыточным в приведенном примере, так как NULL не больше нуля.

!!!! Пример № 12 (SQL)

@@
procedure ...
 @IngenerID int = NULL,
...
AS
...
 SELECT * 
 FROM table1
 WHERE ((@IngenerID IS NULL) OR ((@IngenerID IS NOT NULL) AND (table1.UserID = @IngenerID)))
@@

Очень хитрая конструкция применения фильтра. При фильтре @IngenerID = NULL вывод данных не фильтруется. Читабельней 

@@
WHERE table1.UserID = ISNULL(@IngenerID,table1.UserID)
@@

!!!! Пример 13 (С#) 

Настоящий индиец доверяет генерацию GUID'ов только серверу. Найдите ошибку.

@@
public string GetNewGuid()
{
   SqlConnection connection = new SqlConnection(Resources.ConnectionString);
   connection.Open();
   SqlCommand command = connection.CreateCommand();
   command.CommandText = "select new_id()";
   SqlDataReader reader = command.ExecuteReader();
   reader.Read();
   string guid = reader.GetString(0);
   connection.Close();
   return guid;
}
@@

(спойлер: утекает reader)

!!! Почему именно индусский

В Индии с некоторых времен существует практика оценки производительности труда программиста на основе количества написанного кода. Чем больше кода, тем больше программист работает, и, следовательно, выше его оклад. Шустрые индусы быстро сообразили, как обманывать неквалифицированных заказчиков.

!!! Индусский дебаггинг

Частично является разновидностью индусского кодинга. Суть заключается в том, что при дебаггинге индус убирает видимое проявление проблемы, а не саму проблему (он её даже и не пытается искать). Например:

!!!! Проблема

При чтении одного конкретного рекорда из базы прога падает в функции CalculateTaxes с ошибкой переполнения.

!!!! Человеческий фикс

@@  
IF rs.fields("money") > 1e9 THEN
    Throw New System.Exception("Не может в нашей школе быть таких зарплат. В базе неправильное значение зарплаты для работника " + rs.fields("name") + ", исправьте.") 
  END

  Call CalculateTaxes(rs)
@@

Индусский фикс

@@
  IF rs.fields("name") ="уборщица тётя люся" THEN
    ' Ну и похуй, что налоги для тёти люси не посчитаются. Зато софтина не упадёт!
  ELSE 
    Call CalculateTaxes(rs)
  END
@@

!!! Kитайский код

Kитайский код — стиль написания программ, нарушающий принцип НПС («Не повторяй себя»). Китайский подход к программированию требует эксплицитного отказа от циклов, локальных переменных, любых процедур и условных выражений, а также использования технологии copy-and-paste чуть менее, чем везде. Такой подход увеличивает не только объём исходников, но и производительность (ведь пропускаются такты на джамповые команды[7][8]).

Возьмём, к примеру, такой кусочек программы на C:

@@
int arr[10];
int i;
for (i = 0; i < 10; i++)
{
  arr[i] = 0;
}
@@

Который, кстати, вполне мог бы выглядеть и так:

@@
int arr[10] = { };
@@

Типичный программист в китайском стиле напишет это так:

@@
int a0 = 0;
int a1 = 0;
int a2 = 0;
int a3 = 0;
int a4 = 0;
int a5 = 0;
int a6 = 0;
int a7 = 0;
int a8 = 0;
int a9 = 0;
@@

и в дальнейшем будет использовать a0, a1, a2, a3, a4 и т.д. Например, вместо прекрасного:

@@
if (x < 10) arr[x] = x;
@@

будет:

@@
if (x == 0)
{
  a0 = x;
}
else if (x == 1)
{
  a1 = x;
}
else if (x == 2)
{
  ...
}
@@

Пример #1, приведённый выше:

@@
uint i;
…
if (i.ToString().Length == 1)
{
  ...
}
@@

приверженец китайской методы перепишет так:

@@
if (i == 0 || i == 1 || i == 2 || i == 3 || i == 4 || i == 5 || i == 6 || i == 7 || i == 8 || i == 9)
{
  // произвести ещё одну бессмысленную операцию
}
@@

В то время как суть индусского метода заключается в как можно более полном затуманивании предназначения программного продукта, китайский код зачастую поражает и даже отупляет простотой и брутальной прямолинейностью подхода, что характерно для китайской инженерии в целом. С другой стороны, нельзя не отметить, что подобные технологии позволяют максимальным образом трудоустроить население и приводят к сокрушительным победам в социалистических соревнованиях по количеству написанных строчек.

Если программист в китайском стиле и напишет процедуру, то вероятность того, что результат её деятельности будет совершенно бесполезным, стремится к единице.

Очень часто китайский код пишут тупые студенты, которые пришли учиться по неясным причинам. Потом такой код приходится долго вкуривать. Выражение «ебу и патчу» произошло благодаря как раз таким случаям.

Пример китайского кода на практике: http://community.livejournal.com/code_wtf/160720.html

!!! Голландский код

Пишется в состоянии наркотического опьянения. Без принятия веществ код понять невозможно. Пример: http://opensource.apple.com/source/procmail/procmail-1.2/procmail/src/procmail.c

!!! Анналы истории

29 января 2009 года на открытии Всемирного экономического форума в Давосе афтаритетность и квалифекация наших индусско-индийских коллег была подтверждена на официальном уровне и использована для доказательства не меньшей авторитетности и квалификации нашего брата:[9]

[>
«У нас традиционно хорошо развита математическая школа, и программисты у нас одни из лучших в мире. Это без всяких сомнений. Думаю, что с этим никто не будет спорить, даже наши индийские коллеги.»
В.В. Путин
<]

Следует отметить что подобное сравнение проводил также Билл Гейтс, который во время своего визита в Россию высоко оценил возможности России и потенциал российских специалистов в области высоких технологий и точных наук, и, соответственно, во время последнего визита в Индию, их индусских коллег.

!!! ПРОФИТ!

Как уже говорилось, некотором индусам до сих пор платят не за качество, а за количества кода, в результате чего можно встретить подобные шедевры (и это только цветочки!):

@@
if (true) {
    // какой-то код
} else {
    // a вот тут чистый profit
}
@@

Кодер-кун сообщает, что это - всего лишь затычка из-за нежелания закоментить еще кучу кода, но чтобы закомменченый участок был компилируемым.

И особенно весело получается, когда где-нибудь вверху скромно стоит

@@
...
#define true false
...
@@

Ну и уж совсем замечательно, когда

@@
...
#define true (Math.random()>0.5)
...
@@

Поговаривают, что последний пример уже из области какого-то стохастического программирования.