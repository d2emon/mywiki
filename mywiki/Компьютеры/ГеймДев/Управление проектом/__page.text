!! Управление проектом

!!! Анализ требований

Анализ требований — это процесс сбора требований к программному обеспечению (ПО), их систематизации, документирования, анализа, выявления противоречий, неполноты, разрешения конфликтов в процессе разработки программного обеспечения. В англоязычной среде также говорят о дисциплине «инженерия требований» (англ. Requirements Engineering). В процессе сбора требований важно принимать во внимание возможные противоречия требований различных заинтересованных лиц, таких как заказчики, разработчики или пользователи.

Полнота и качество анализа требований играют ключевую роль в успехе всего проекта. Требования к ПО должны быть документируемые, выполнимые, тестируемые, с уровнем детализации достаточным для проектирования системы. Требования могут быть функциональными и нефункциональными.

Анализ требований включает три типа деятельности:

# Сбор требований: общение с клиентами и пользователями, чтобы определить, каковы их требования.
# Анализ требований: определение, являются ли собранные требования неясными, неполными, неоднозначными, или противоречащими, и затем решение этих проблем.
# Документирование требований: Требования могут быть задокументированы в различных формах, таких как простое описание, сценарии использования, пользовательские истории, или спецификации процессов.

Анализ требований может быть длинным и трудным процессом, во время которого вовлечены много тонких психологических навыков. Новые системы изменяют окружающую среду и отношения между людьми, таким образом важно определить все заинтересованные лица, принять во внимание все их потребности и гарантировать, что они понимают значения новых систем. Аналитики могут использовать несколько методов, чтобы выявить требования от клиента такие, как проведение интервью, или использование фокус-групп и создание списков требований. Более современные методы включают создание прототипов и сценариев использования. Где необходимо, аналитик будет использовать комбинацию этих методов, чтобы выявить точные требования заинтересованных лиц, таким образом, чтобы была создана система, которая удовлетворяет деловые потребности.

!!!! Фазы

Процесс анализа требований к информационной системе включает следующие фазы:

* Разработки требований
* Выявление требований
* Анализ требований
* Спецификация требований
* Проверка требований
* Управления требованиями

!!!! Выявление и анализ требований

!!!!!  Идентификация заинтересованного лица

Заинтересованные лица являются людьми или организациями (юридические лица, такие как компании, комитеты по стандартизации), у которых есть действительный интерес к системе. Они могут быть затронуты этой системой прямо или косвенно. Начиная с 1990-х основной акцент при разработке требований ставится на идентификации заинтересованных лиц. При этом нужно учесть что заинтересованные лица не ограничены организацией, нанимающей аналитика. К заинтересованным лицам также относятся:

* любой, кто пользуется системой (пользователи и обслуживающий персонал)
* любой, кто извлекает выгоду из системы (функциональную, политическую, финансовую и социальную)
* любой вовлечённый в покупку или обеспечение системы
* организации, которые регулируют аспекты системы (финансовые, безопасность, и другие)
* люди или организации, настроенные против системы (отрицательные заинтересованные лица),
* организации, ответственные за системы, которые взаимодействуют с системой согласно проекту
* те организации, которые объединяются горизонтально с организацией, для которой аналитик проектирует систему

!!!!! Опрос заинтересованных лиц

Опрос заинтересованных лиц является широко используемой техникой при сборе требований. Эти опросы могут выявлять требования не попавшие в рамки проекта либо противоречащие ранее собранным. Однако каждое заинтересованное лицо будет иметь собственные требования, ожидания и видение системы.

!!!!! Сеансы совместного развития требований (СРТ)

Требования часто имеют сложное, пересекающееся функциональное назначение, не известное отдельным заинтересованным лицам. Такие требования часто упускаются или не полностью определяются во время опросов заинтересованных лиц. Такие требования могут быть выявлены при проведении сеансов СРТ. Такие сеансы проводятся под надзором подготовленного специалиста. Заинтересованные лица участвуют в обсуждениях чтобы определить требования, проанализировать их детали и выявить скрытые, пересекающиеся взаимосвязи между требованиями. На сеансах также присутствуют стенографист и аналитик. Использование отдельного стенографиста и специалиста по ведению обсуждений позволяют аналитику сосредоточиться на выявлении требований.

!!!! Спецификация требований

!!!!! Списки требований

Одним традиционным способом документировать требования было создание списков требований. В сложной системе такие списки требований могут занимать сотни страниц.

Соответствующей метафорой может быть чрезвычайно длинный список покупок в магазине. Такие списки крайне неэффективны в современном анализе, хотя используются и по сей день.

!!!!! Преимущества

* Обеспечивает контрольный список требований.
* Обеспечивает договор между заказчиком(ами) и разработчиками.
* Для большой системы может обеспечить описание высокого уровня.

!!!!! Недостатки

* Такие списки могут занимать сотни страниц. Фактически невозможно прочитать такие документы в целом и получить чёткое понимание системы.
* Такие списки требований перечисляют отдельные требования абстрактно, оторванно друг от друга и от контекста использования
** Эта абстракция лишает возможности видеть, как требования связываются между собой или работают вместе.
** Эта абстракция мешает верно расположить требования по приоритетам; в то время как список, действительно облегчает приоретизацию отдельных пунктов, удаление одного пункта из контекста может сделать весь сценарий использования или деловое требование бесполезным.
** Эта абстракция увеличивает вероятность неверного трактования требований; поскольку чем больше число людей будет их читать, тем большее будет число (различных) интерпретаций системы.
** Эта абстракция означает, что чрезвычайно трудно убедиться, что у вас есть все необходимые требования.
* Эти списки создают ложное чувство взаимопонимания между заинтересованными лицами и разработчиками.
* Эти списки дают заинтересованным лицам ложное чувство защищённости, что разработчики должны достигнуть определённых вещей. Однако, из-за природы этих списков, они неизбежно упускают важные требования, которые будут выявлены позже в процессе. Разработчики могут использовать новые требования для пересмотра сроков и условий в их пользу.

!!!!! Альтернативы спискам требования

Альтернативами большим, предопределенным спискам требований могут служить пользовательские истории, которые определяют требования обычным языком.

!!!! Измеримые цели

Лучшие методы рассматривают составленный список требований просто как подсказки и постоянно спрашивают «почему?» пока не будут выявлены истинные деловые цели. После этого заинтересованные лица и разработчики могут разработать тесты измеряющие, какой уровень каждой цели был достигнут. Такие цели изменяются медленнее чем длинный список определённых но неизмеримых требований. Как только маленький набор критических, измеримых целей установлен, быстрое прототипирование и короткие этапы разработки могут дать заинтересованным лицам реальную ценность ещё до окончания проекта.

!!!!! Прототипы (опытные образцы)

В середине 1980-х прототипирование (англ. prototyping) рассматривалось как решение проблемы анализа требований. Прототипы — макеты системы. Макеты дают возможность пользователям представить систему, которая ещё не построена. Опытные образцы помогают пользователям представить на что будет похожа система, и облегчают пользователям принятие проектных решений, не дожидаясь окончания постройки системы. Наибольшие улучшения во взаимопонимании между пользователями и разработчиками часто замечались с введением опытных образцов. Ранние обзоры системы приводят к меньшему количеству изменений на поздних стадиях разработки и следовательно значительно уменьшают затраты.

Однако, за следующее десятилетие, прототипирование хоть и было признано эффективной техникой, однако не решило проблему анализа требований:

* Менеджерам, как только они видят опытный образец, сложно понять, что окончательный проект не будет разработан ещё некоторое время.
* Проектировщики часто чувствуют себя вынужденными использовать опытный образец в реальной системе, потому что они боятся «напрасно тратить время», начиная всё сначала.
* Опытные образцы преимущественно помогают с проектными решениями и дизайном пользовательского интерфейса. Однако, они не могут сказать Вам, какими были первоначальные требования.
* Проектировщики и конечные пользователи могут слишком сильно сосредоточиться на дизайне пользовательского интерфейса и слишком мало на производстве системы, которая служит бизнес-процессу.
* Прототипы отлично подходят для пользовательских интерфейсов, но мало полезны для сложной обработки данных или асинхронных процессов, которые могут вовлечь сложные обновления базы данных и/или вычисления.

Опытные образцы могут быть плоскими диаграммами (часто называемые каркасами) или рабочими программами, использующими синтетические функциональные возможности. Каркасы могут быть представлены графическими документами. В случаях, где законченное программное обеспечение должно иметь графическое оформление, из каркаса удаляют цвет (то есть используют серую палитру цветов). Это помогает предотвратить недоразумения по поводу окончательного вида программы.

!!!!! Сценарии использования

Вариант использования (англ. Use Case) — техника для документации потенциальных требований для создания новой системы или изменения существующей. Каждый вариант описывает один или несколько способов взаимодействия системы с конечным пользователем или другой системой, для достижения определённой цели. Варианты использования обычно избегают технического жаргона, предпочитая вместо этого язык конечного пользователя или эксперта в данной области. Они часто создаются совместно специалистами по сбору требований и заинтересованными лицами.

Варианты использования — наиболее важный инструмент для моделирования требований с целью спецификации функциональных возможностей разрабатываемого программного обеспечения или системы в целом. Они могут содержать дополнительное текстовое описание всех способов, которыми пользователи могут работать с программным обеспечением или системой. Такое текстовое описание называется сценарием. Как правило, варианты использования отвечают на вопрос «Что должна выполнить система для конкретного актера(англ. Actor)?», не отвечая на вопрос «Каким образом система должна это реализовать?» Текст сценария в этом случае дополняет графическое представление вариантов использования в форме описания последовательности шагов или действий, следуя которым пользователь может достичь желаемой цели при взаимодействии с системой. Полнота функциональных требований к разрабатываемой системе достигается спецификацией всех вариантов использования с соответствующими сценариями, отражающими все пожелания и потребности пользователей к разрабатываемой системе.

!!!!! Спецификация требований программного обеспечения

Спецификация требований программного обеспечения (англ. Software Requirements Specification, SRS) является полным описанием поведения системы, которая будет создана. Она включает ряд сценариев использования, которые описывают все виды взаимодействия пользователей с программным обеспечением. Сценарии использования также известны как функциональные требования. В дополнении к сценариям использования, спецификация программного обеспечения также содержат нефункциональные (или дополнительные) требования. Нефункциональные требования — требования, которые налагают дополнительные ограничения на систему (такие как требования эффективности работы, стандарты качества, или проектные ограничения).

Рекомендуемые подходы для спецификации требований программного обеспечения описаны стандартом IEEE 830—1998. Этот стандарт описывает возможные структуры, желательное содержание, и качества спецификации требований программного обеспечения.

!!!! Типы требований

Требования систематизируются несколькими способами. Ниже представлены общие классификации требований, которые касаются технического управления:

!!!!! Требования клиентов

Клиенты, это те, кто выполняет основные функции системного проектирования, со специальным акцентом на пользователе системы как ключевом клиенте. Пользовательские требования определят главную цель системы и, как минимум, ответят на следующие вопросы:

* Требования эксплуатации или развёртывания: Где система будет использоваться?
* Профиль миссии или сценарий: Как система достигнет целей миссии?
* Требования производительности: Какие параметры системы являются критическими для достижения миссии?
* Сценарии использования: Как различные компоненты системы должны использоваться?
* Требования эффективности: Насколько эффективной должна быть система для выполнения миссии?
* Эксплуатационный жизненный цикл: Как долго система будет использоваться?
* Окружающая среда: Каким окружением система должна будет эффективно управлять?

!!!!! Функциональные требования

Функциональные требования объясняют, что должно быть сделано. Они идентифицируют задачи или действия, которые должны быть выполнены. Функциональные требования определяют действия, которые система должна быть способной выполнить, связь входа/выхода в поведении системы.

!!!!! Нефункциональные требования

Нефункциональные требования — требования, которые определяют критерии работы системы в целом, а не отдельные сценарии поведения. Нефункциональные требования определяют системные свойства такие как производительность, удобство сопровождения, расширяемость, надежность, средовые факторы эксплуатации.

!!!!! Требования производительности

Степень, до которой должны быть выполнены миссия или функция; в общем случае измеренные с точки зрения количества, качества, покрытия, своевременности или готовности.

!!!!! Производные требования

Требования, которые подразумеваются или преобразованы из высокоуровневого требования. Например, требование для большего радиуса действия или высокой скорости может привести к требованию низкого веса.

Известные модели классификации требований включают FURPS и FURPS+, разработанные в Hewlett-Packard.

!!!! Проблемы анализа требований

!!!!! Проблемы заинтересованных лиц

Стив Макконнелл, в его книге «Быстрое развитие»[2], подробно описывает как пользователи могут препятствовать сбору требований:

* Пользователи не понимают то, что они хотят, или у пользователей нет ясного представления об их требованиях
* Пользователи не соглашаются с ранее записанными требованиями
* Пользователи настаивают на новых требованиях после того, как стоимость и график работ были установлены
* Коммуникация с пользователями является медленной
* Пользователи часто не участвуют в обзорах требований или неспособны в них участвовать
* Пользователи технически неподготовлены
* Пользователи не понимают процесса разработки ПО

Это может привести к ситуации, где пользовательские требования продолжают изменяться, даже когда система или разработка новой продукции были начаты.

!!!!! Проблемы инженеров / разработчиков

Возможные проблемы, вызванные инженерами и разработчиками во время анализа требований:

* У технического персонала и конечных пользователей могут быть различные мнения. Следовательно, они могут неправильно полагать, что они находятся во взаимопонимании, пока готовое изделие не будет отправлено.
* Инженеры и разработчики могут попытаться подкорректировать требования чтобы они соответствовали существующей системе или модели, вместо того, чтобы разработать систему, соответствующую потребностям клиента.
* Анализ может часто выполняться инженерами или программистами, а не персоналом с навыками работы с людьми и знаниями проблемной области.

!!!!! Решения проблем

Одно из решений проблемы общения состояло в том, чтобы нанять специалистов в деловом или системном анализе.

Методики, введённые в 1990-х — прототипирование, унифицированный язык моделирования (UML), сценарии использования и гибкая методология разработки, — также предназначены для решения описанных выше проблем.

!!! Проектирование программного обеспечения

Проектирование программного обеспечения — процесс создания проекта программного обеспечения (ПО), а также дисциплина, изучающая методы проектирования. Проектирование ПО является частным случаемПроектирования продуктов и процессов.

Целью проектирования является определение внутренних свойств системы и детализации её внешних (видимых) свойств на основе выданных заказчиком требований к ПО (исходные условия задачи). Эти требования подвергаются анализу.

Первоначально программа рассматривается как чёрный ящик. Ход процесса проектирования и его результаты зависят не только от состава требований, но и выбранной модели процесса, опыта проектировщика.

Модель предметной области накладывает ограничения на бизнес-логику и структуры данных.

В зависимости от класса создаваемого ПО, процесс проектирования может обеспечиваться как «ручным» проектированием, так и различными средствами его автоматизации. В процессе проектирования ПО для выражения его характеристик используются различные нотации — блок-схемы, ER-диаграммы, UML-диаграммы, DFD-диаграммы, а также макеты.

Проектированию обычно подлежат:

* Архитектура ПО;
* Устройство компонентов ПО;
* Пользовательские интерфейсы.

В российской практике проектирование ведется поэтапно в соответствии со стадиями, регламентированными ГОСТ 2.103-68: Техническое задание, Техническое предложение, Эскизный проект, Технический проект, Рабочий проект.[1]На каждом из этапов формируется свой комплект документов, называемый проектом (проектной документацией).

В зарубежной практике регламентирующими документами, например, являются Software Architecture Document, Software Design Document.

!!! Программирование

Программи́рование — процесс создания компьютерных программ.

В узком смысле (так называемое кодирование) под программированием понимается написание инструкций (программ) на конкретном языке программирования (часто по уже имеющемуся алгоритму — плану, методу решения поставленной задачи). Соответственно, люди, которые этим занимаются, называются программистами (на профессиональном жаргоне — кодерами), а те, кто разрабатывают алгоритмы — алгоритмистами, специалистами предметной области, математиками.

В более широком смысле под программированием понимают весь спектр деятельности, связанный с созданием и поддержанием в рабочем состоянии программ — программного обеспечения ЭВМ. Иначе это называется «программная инженерия» («инженерия ПО»). Сюда входят анализ и постановка задачи, проектирование программы, построение алгоритмов, разработка структур данных, написание текстов программ, отладка и тестирование программы (испытания программы), документирование, настройка (конфигурирование), доработка и сопровождение.

Программирование для ЭВМ основывается на использовании языков программирования, на которых записывается программа. Чтобы программа могла быть понята и исполнена ЭВМ, требуется специальный инструмент — транслятор.

В настоящее время активно используются интегрированные среды разработки, включающие в свой состав также редактор для ввода и редактирования текстов программ, отладчики для поиска и устранения ошибок, трансляторы с различных языков программирования, компоновщики для сборки программы из нескольких модулей и другие служебные модули.

Текстовый редактор среды программирования может иметь специфичную функциональность, такую как индексация имен, отображение документации, средства визуального создания пользовательского интерфейса. С помощью текстового редактора программист производит набор и редактирования текста создаваемой программы, который называют исходным кодом. Язык программирования определяет синтаксис и изначальную семантику исходного кода.Компилятор преобразует текст программы в машинный код, непосредственно исполняемый электронными компонентами компьютера. Интерпретатор создаёт виртуальную машину для выполнения программы, которая полностью или частично берёт на себя функции исполнения программ.

Программирование в широком смысле можно разбить на несколько стадий:

* Анализ
* Проектирование — разработка комплекса алгоритмов
* Кодирование и компиляцию — написание исходного текста программы и преобразование его в исполнимый код с помощью компилятора
* Тестирование и отладку — выявление и устранение ошибок в программах,
* Испытания и сдачу программ
* Сопровождение

!!!! История

Антикитерский механизм из Древней Греции был калькулятором, использовавшим шестерни различных размеров и конфигурации, обусловливавших его работу,[1] по отслеживанию метонова цикла, до сих пор использующегося влунно-солнечных календарях.[2] Аль-Джазари построил программируемый автомат-гуманоид в 1206 году. Одна система, задействованная в этих устройствах, использовала зажимы и кулачки, помещённые в деревянный ящик в определённых местах, которые последовательно задействовали рычаги, которые, в свою очередь, управляли ударными инструментами.

Часто первым программируемым устройством принято считать жаккардовый ткацкий станок, построенный в 1804 году Жозефом Мари Жаккаром, который произвёл революцию в ткацкой промышленности, предоставив возможность программировать узоры на тканях при помощи перфокарт.

Первое программируемое вычислительное устройство, Аналитическую машину, разработал Чарлз Бэббидж (но не смог её построить). 19 июля 1843 года графиня Ада Августа Лавлейс, дочь великого английского поэта Джорджа Байрона, как принято считать, написала первую в истории человечества программу для Аналитической машины. Эта программа решала уравнение Бернулли, выражающее закон сохранения энергии движущейся жидкости. В своей первой и единственной научной работе Ада Лавлейс рассмотрела большое число вопросов. Ряд высказанных ею общих положений (принцип экономии рабочих ячеек памяти, связь рекуррентных формул с циклическими процессами вычислений) сохранили свое принципиальное значение и для современного программирования. В материалах Бэббиджа и комментариях Лавлейс намечены такие понятия, как подпрограмма и библиотека подпрограмм, модификация команд и индексный регистр, которые стали употребляться только в 1950-х годах. Однако ни одна из программ написанных Адой Лавлейс никогда так и не была запущена.

!!!! Языки программирования

Большая часть работы программистов связана с написанием исходного кода, тестированием и отладкой программ на одном из языков программирования. Исходные тексты и исполняемые файлы программ являются объектами авторского права и являются интеллектуальной собственностью их авторов и правообладателей.

Различные языки программирования поддерживают различные стили программирования (парадигмы программирования). Отчасти искусство программирования состоит в том, чтобы выбрать язык программирования, наиболее полно подходящий для решения поставленной задачи. Разные языки требуют от программиста различного уровня внимания к деталям при реализации алгоритма, результатом чего часто бывает компромисс между простотой и производительностью (или между временем программиста и временем пользователя).

Единственный язык, напрямую выполняемый ЭВМ — это машинный язык (также называемый машинным кодом и языком машинных команд). Изначально все программы писались в машинном коде, но сейчас этого практически уже не делается. Вместо этого программисты пишут исходный код на том или ином языке программирования, затем, используя компилятор, транслируют его в один или несколько этапов в машинный код, готовый к исполнению на целевом процессоре, или в промежуточное представление, которое может быть исполнено специальным интерпретатором — виртуальной машиной. Но это справедливо только для языков высокого уровня. Если требуется полный низкоуровневый контроль над системой на уровне машинных команд и отдельных ячеек памяти, программы пишут на языке ассемблера, мнемонические инструкции которого преобразуются один к одному в соответствующие инструкции машинного языка целевого процессора ЭВМ. (По этой причине трансляторы с языков ассемблера — ассемблера — получаются алгоритмически простейшими трансляторами.)

В некоторых языках вместо машинного кода генерируется интерпретируемый двоичный код «виртуальной машины», также называемый байт-кодом (byte-code). Такой подход применяется в Forth, некоторых реализациях Lisp, Java, Perl, Python, языках для .NET Framework.

!!!! Программные средства

При разработке на любом языке программирования совершенно необходимым средством является компилятор или интерпретатор. Важным, хотя, строго говоря, не абсолютно необходимым элементом разработки является IDE (Integrated Developing Environment) или среда разработки -- программная система, упрощающая написание кода, его отладку, генерацию документации и т.п.. В промышленном программировании на языках C++ и C# чаще всего используется Microsoft Visual Studio[источник не указан 30 дней].

На олимпиадах по информатике и программированию с успехом используются только свободно распространяемые лицензионные инструментальные средства (в большинстве своём распространяются по лицензии GNU GPL). Из языков программирования на олимпиадах по программированию последние годы часто используются языки программирования Паскаль, C/C++ и Java.

!!! Документация на программное обеспечение

Документа́ция на программное обеспечение — печатные руководства пользователя, диалоговая (оперативная) документация и справочный текст, описывающие, как пользоваться программным продуктом.

Документ — элемент документации: целевая информация, предназначенная для конкретной аудитории, размещенная на конкретном носителе (например, в книге, на диске, в краткой справочной карте) в заданном формате.

Программный документ — документ, содержащий в зависимости от назначения данные, необходимые для разработки, производства, эксплуатации, сопровождения программы или программного средства.

Типы документации
Существует четыре основных типа документации на ПО:
архитектурная/проектная — обзор программного обеспечения, включающий описание рабочей среды и принципов, которые должны быть использованы при создании ПО
техническая — документация на код, алгоритмы, интерфейсы, API
пользовательская — руководства для конечных пользователей, администраторов системы и другого персонала
маркетинговая
Архитектурная/проектная документация
Проектная документация обычно описывает продукт в общих чертах. Не описывая того, как что-либо будет использоваться, она скорее отвечает на вопрос «почему именно так?» Например, в проектном документе программист может описать обоснование того, почему структуры данных организованы именно таким образом. Описываются причины, почему какой-либо класс сконструирован определённым образом, выделяются паттерны, в некоторых случаях даже даются идеи как можно будет выполнить улучшения в дальнейшем. Ничего из этого не входит в техническую или пользовательскую документацию, но всё это действительно важно для проекта.
Техническая документация
При создании программы, одного лишь кода, как правило, недостаточно. Должен быть предоставлен некоторый текст, описывающий различные аспекты того, что именно делает код. Такая документация часто включается непосредственно в исходный код или предоставляется вместе с ним.
Подобная документация имеет сильно выраженный технический характер и в основном используется для определения и описания API, структур данных и алгоритмов.
Часто при составлении технической документации используются автоматизированные средства — генераторы документации, такие как Doxygen, javadoc, NDoc и другие. Они получают информацию из специальным образом оформленных комментариев в исходном коде, и создают справочные руководства в каком-либо формате, например, в виде текста или HTML.
Использование генераторов документации и документирующих комментариев многими программистами признаётся удобным средством, по различным причинам. В частности, при таком подходе документация является частью исходного кода, и одни и те же инструменты могут использоваться для сборки программы и одновременной сборки документации к ней. Это также упрощает поддержку документации в актуальном состоянии.
Пользовательская документация
В отличие от технической документации, сфокусированной на коде и том, как он работает, пользовательская документация описывает лишь то, как использовать программу.
В случае если продуктом является программная библиотека, пользовательская документация и документация на код становятся очень близкими, почти эквивалентными понятиями. Но в общем случае, это не так.
Обычно, пользовательская документация представляет собой руководство пользователя, которое описывает каждую функцию программы, а также шаги, которые нужно выполнить для использования этой функции. Хорошая пользовательская документация идёт ещё дальше и предоставляет инструкции о том что делать в случае возникновения проблем. Очень важно, чтобы документация не вводила в заблуждение и была актуальной. Руководство должно иметь чёткую структуру; очень полезно, если имеется сквозной предметный указатель. Логическая связность и простота также имеют большое значение.
Существует три подхода к организации пользовательской документации. Вводное руководство (англ. tutorial), наиболее полезное для новых пользователей, последовательно проводит по ряду шагов, служащих для выполнения каких-либо типичных задач. Тематический подход, при котором каждая глава руководства посвящена какой-то отдельной теме, больше подходит для совершенствующихся пользователей. В последнем, третьем подходе, команды или задачи организованы в виде алфавитного справочника — часто это хорошо воспринимается продвинутыми пользователями, хорошо знающими, что они ищут. Жалобы пользователей обычно относятся к тому, что документация охватывает только один из этих подходов, и поэтому хорошо подходит лишь для одного класса пользователей.
Во многих случаях разработчики программного продукта ограничивают набор пользовательской документации лишь встроенной системой помощи (англ. online help), содержащей справочную информацию о командах или пунктах меню. Работа по обучению новых пользователей и поддержке совершенствующихся пользователей перекладывается на частных издателей, часто оказывающих значительную помощь разработчикам.
Маркетинговая документация
Для многих приложений необходимо располагать рядом рекламные материалы, с тем чтобы заинтересовать людей, обратив их внимание на продукт. Такая форма документации имеет целью:
подогреть интерес к продукту у потенциальных пользователей
информировать их о том, что именно делает продукт, с тем чтобы их ожидания совпадали с тем, что они получат
объяснить положение продукта по сравнению с конкурирующими решениями
Одна из хороших маркетинговых практик — предоставление слогана — простой запоминающейся фразы, иллюстрирующей то, что мы хотим донести до пользователя, а также характеризующей ощущение, которое создаёт продукт.
Часто бывает так, что коробка продукта и другие маркетинговые материалы дают более ясную картину о возможностях и способах использования программы, чем всё остальное.
Тестирование программного обеспечения
Тести́рование програ́ммного обеспе́чения — процесс исследования, испытания программного обеспечения (ПО) с целью получения информации о качестве продукта.
Введение
Существующие на сегодняшний день методы тестирования ПО не позволяют однозначно и полностью выявить все дефекты и установить корректность функционирования анализируемой программы, поэтому все существующие методы тестирования действуют в рамках формального процесса проверки исследуемого или разрабатываемого ПО.
Такой процесс формальной проверки, или верификации, может доказать, что дефекты отсутствуют с точки зрения используемого метода. (То есть нет никакой возможности точно установить или гарантировать отсутствие дефектов в программном продукте с учётом человеческого фактора, присутствующего на всех этапах жизненного цикла ПО).
Существует множество подходов к решению задачи тестирования и верификации ПО, но эффективное тестирование сложных программных продуктов — это процесс в высшей степени творческий, не сводящийся к следованию строгим и чётким процедурам или созданию таковых.
С точки зрения ISO 9126, качество программного обеспечения можно определить как совокупную характеристику исследуемого ПО с учётом следующих составляющих:
Надёжность
Сопровождаемость
Практичность
Эффективность
Мобильность
Функциональность
Более полный список атрибутов и критериев можно найти в стандарте ISO 9126 Международной организации по стандартизации. Состав и содержание документации, сопутствующей процессу тестирования, определяется стандартом IEEE 829-1998 Standard for Software Test Documentation.
История развития тестирования программного обеспечения
Первые программные системы разрабатывались в рамках программ научных исследований или программ для нужд министерств обороны. Тестирование таких продуктов проводилось строго формализовано с записью всех тестовых процедур, тестовых данных, полученных результатов. Тестирование выделялось в отдельный процесс, который начинался после завершения кодирования, но при этом, как правило, выполнялось тем же персоналом.
В 1960-х много внимания уделялось «исчерпывающему» тестированию, которое должно проводиться с использованием всех путей в коде или всех возможных входных данных. Было отмечено, что в этих условиях полное тестирование ПО невозможно, потому что, во-первых, количество возможных входных данных очень велико, во-вторых, существует множество путей, в-третьих, сложно найти проблемы в архитектуре и спецификациях. По этим причинам «исчерпывающее» тестирование было отклонено и признано теоретически невозможным.
В начале 1970-х тестирование ПО обозначалось как «процесс, направленный на демонстрацию корректности продукта» или как «деятельность по подтверждению правильности работы ПО». В зарождавшейся программной инженерии верификация ПО значилась как «доказательство правильности». Хотя концепция была теоретически перспективной, на практике она требовала много времени и была недостаточно всеобъемлющей. Было решено, что доказательство правильности — неэффективный метод тестирования ПО. Однако, в некоторых случаях демонстрация правильной работы используется и в наши дни, например, приемо-сдаточные испытания. Во второй половине 1970-х тестирование представлялось как выполнение программы с намерением найти ошибки, а не доказать, что она работает. Успешный тест — это тест, который обнаруживает ранее неизвестные проблемы. Данный подход прямо противоположен предыдущему. Указанные два определения представляют собой «парадокс тестирования», в основе которого лежат два противоположных утверждения: с одной стороны, тестирование позволяет убедиться, что продукт работает хорошо, а с другой — выявляет ошибки в ПО, показывая, что продукт не работает. Вторая цель тестирования является более продуктивной с точки зрения улучшения качества, так как не позволяет игнорировать недостатки ПО.
В 1980-х тестирование расширилось таким понятием, как предупреждение дефектов. Проектирование тестов — наиболее эффективный из известных методов предупреждения ошибок. В это же время стали высказываться мысли, что необходима методология тестирования, в частности, что тестирование должно включать проверки на всем протяжении цикла разработки, и это должен быть управляемый процесс. В ходе тестирования надо проверить не только собранную программу, но и требования, код, архитектуру, сами тесты. «Традиционное» тестирование, существовавшее до начала 1980-х, относилось только к скомпилированной, готовой системе (сейчас это обычно называется системное тестирование), но в дальнейшем тестировщики стали вовлекаться во все аспекты жизненного цикла разработки. Это позволяло раньше находить проблемы в требованиях и архитектуре и тем самым сокращать сроки и бюджет разработки. В середине 1980-х появились первые инструменты для автоматизированного тестирования. Предполагалось, что компьютер сможет выполнить больше тестов, чем человек, и сделает это более надежно. Поначалу эти инструменты были крайне простыми и не имели возможности написания сценариев на скриптовых языках.
В начале 1990-х в понятие «тестирование» стали включать планирование, проектирование, создание, поддержку и выполнение тестов и тестовых окружений, и это означало переход от тестирования к обеспечению качества, охватывающего весь цикл разработки ПО. В это время начинают появляться различные программные инструменты для поддержки процесса тестирования: более продвинутые среды для автоматизации с возможностью создания скриптов и генерации отчетов, системы управления тестами, ПО для проведения нагрузочного тестирования. В середине 1990-х с развитием Интернета и разработкой большого количества веб-приложений особую популярность стало получать «гибкое тестирование» (по аналогии с гибкими методологиями программирования).
В 2000-х появилось еще более широкое определение тестирования, когда в него было добавлено понятие «оптимизация бизнес-технологий» (en:business technology optimization, BTO). BTO направляет развитие информационных технологий в соответствии с целями бизнеса. Основной подход заключается в оценке и максимизации значимости всех этапов жизненного цикла разработки ПО для достижения необходимого уровня качества, производительности, доступности.
Тестирование программного обеспечения
Существует несколько признаков, по которым принято производить классификацию видов тестирования. Обычно выделяют следующие:
По объекту тестирования:
Функциональное тестирование (functional testing)
Тестирование производительности (performance testing)
Нагрузочное тестирование (load testing)
Стресс-тестирование (stress testing)
Тестирование стабильности (stability / endurance / soak testing)
Юзабилити-тестирование (usability testing)
Тестирование интерфейса пользователя (UI testing)
Тестирование безопасности (security testing)
Тестирование локализации (localization testing)
Тестирование совместимости (compatibility testing)
По знанию системы:
Тестирование чёрного ящика (black box)
Тестирование белого ящика (white box)
Тестирование серого ящика (grey box)
По степени автоматизации:
Ручное тестирование (manual testing)
Автоматизированное тестирование (automated testing)
Полуавтоматизированное тестирование (semiautomated testing)
По степени изолированности компонентов:
Компонентное (модульное) тестирование (component/unit testing)
Интеграционное тестирование (integration testing)
Системное тестирование (system/end-to-end testing)
По времени проведения тестирования:
Альфа-тестирование (alpha testing)
Дымовое тестирование (smoke testing)
Тестирование новой функциональности (new feature testing)
Регрессионное тестирование (regression testing)
Тестирование при сдаче (acceptance testing)
Бета-тестирование (beta testing)
По признаку позитивности сценариев:
Позитивное тестирование (positive testing)
Негативное тестирование (negative testing)
По степени подготовленности к тестированию:
Тестирование по документации (formal testing)
Тестирование ad hoc или интуитивное тестирование (ad hoc testing)
Уровни тестирования
Модульное тестирование (юнит-тестирование) — тестируется минимально возможный для тестирования компонент, например, отдельный класс или функция. Часто модульное тестирование осуществляется разработчиками ПО.
Интеграционное тестирование — тестируются интерфейсы между компонентами, подсистемами или системами. При наличии резерва времени на данной стадии тестирование ведётся итерационно, с постепенным подключением последующих подсистем.
Системное тестирование — тестируется интегрированная система на её соответствие требованиям.
Альфа-тестирование — имитация реальной работы с системой штатными разработчиками, либо реальная работа с системой потенциальными пользователями/заказчиком. Чаще всего альфа-тестирование проводится на ранней стадии разработки продукта, но в некоторых случаях может применяться для законченного продукта в качестве внутреннего приёмочного тестирования. Иногда альфа-тестирование выполняется под отладчиком или с использованием окружения, которое помогает быстро выявлять найденные ошибки. Обнаруженные ошибки могут быть переданы тестировщикам для дополнительного исследования в окружении, подобном тому, в котором будет использоваться ПО.
Бета-тестирование — в некоторых случаях выполняется распространение предварительной версии (в случае проприетарного ПО иногда с ограничениями по функциональности или времени работы) для некоторой большей группы лиц с тем, чтобы убедиться, что продукт содержит достаточно мало ошибок. Иногда бета-тестирование выполняется для того, чтобы получить обратную связь о продукте от его будущих пользователей.
Часто для свободного/открытого ПО стадия альфа-тестирования характеризует функциональное наполнение кода, а бета-тестирования — стадию исправления ошибок. При этом как правило на каждом этапе разработки промежуточные результаты работы доступны конечным пользователям.
Статическое и динамическое тестирование
Описанные ниже техники — тестирование белого ящика и тестирование чёрного ящика — предполагают, что код исполняется, и разница состоит лишь в той информации, которой владеет тестировщик. В обоих случаях это динамическое тестирование.
При статическом тестировании программный код не выполняется — анализ программы происходит на основе исходного кода, который вычитывается вручную, либо анализируется специальными инструментами. В некоторых случаях, анализируется не исходный, а промежуточный код (такой как байт-код или код на MSIL).
Также к статическому тестированию относят тестирование требований, спецификаций, документации.
Регрессионное тестирование
После внесения изменений в очередную версию программы, регрессионные тесты подтверждают, что сделанные изменения не повлияли на работоспособность остальной функциональности приложения. Регрессионное тестирование может выполняться как вручную, так и средствами автоматизации тестирования.
Тестовые скрипты
Тестировщики используют тестовые скрипты на разных уровнях: как в модульном, так и в интеграционном и системном тестировании. Тестовые скрипты, как правило, пишутся для проверки компонентов, в которых наиболее высока вероятность появления отказов или вовремя не найденная ошибка может быть дорогостоящей.
Тестирование «белого ящика» и «чёрного ящика»
В терминологии профессионалов тестирования, фразы «тестирование белого ящика» и «тестирование чёрного ящика» относятся к тому, имеет ли разработчик тестов доступ к исходному коду тестируемого ПО, или же тестирование выполняется через пользовательский интерфейс либо прикладной программный интерфейс, предоставленный тестируемым модулем.
При тестировании белого ящика (англ. white-box testing, также говорят — прозрачного ящика), разработчик теста имеет доступ к исходному коду программ и может писать код, который связан с библиотеками тестируемого ПО. Это типично для юнит-тестирования (англ. unit testing), при котором тестируются только отдельные части системы. Оно обеспечивает то, что компоненты конструкции — работоспособны и устойчивы, до определённой степени. При тестировании белого ящика используются метрики покрытия кода или мутационное тестирование.
При тестировании чёрного ящика, тестировщик имеет доступ к ПО только через те же интерфейсы, что и заказчик или пользователь, либо через внешние интерфейсы, позволяющие другому компьютеру либо другому процессу подключиться к системе для тестирования. Например, тестирующий модуль может виртуально нажимать клавиши или кнопки мыши в тестируемой программе с помощью механизма взаимодействия процессов, с уверенностью в том, все ли идёт правильно, что эти события вызывают тот же отклик, что и реальные нажатия клавиш и кнопок мыши. Как правило, тестирование чёрного ящика ведётся с использованием спецификаций или иных документов, описывающих требования к системе. Как правило, в данном виде тестирования критерий покрытия складывается из покрытия структуры входных данных, покрытия требований и покрытия модели (в тестировании на основе моделей).
При тестировании серого ящика разработчик теста имеет доступ к исходному коду, но при непосредственном выполнении тестов доступ к коду, как правило, не требуется.
Если «альфа-» и «бета-тестирование» относятся к стадиям до выпуска продукта (а также, неявно, к объёму тестирующего сообщества и ограничениям на методы тестирования), тестирование «белого ящика» и «чёрного ящика» имеет отношение к способам, которыми тестировщик достигает цели.
Бета-тестирование в целом ограничено техникой чёрного ящика (хотя постоянная часть тестировщиков обычно продолжает тестирование белого ящика параллельно бета-тестированию). Таким образом, термин «бета-тестирование» может указывать на состояние программы (ближе к выпуску чем «альфа»), или может указывать на некоторую группу тестировщиков и процесс, выполняемый этой группой. Итак, тестировщик может продолжать работу по тестированию белого ящика, хотя ПО уже «в бете» (стадия), но в этом случае он не является частью «бета-тестирования» (группы/процесса).
Покрытие кода
Покрытие кода, по своей сути, является тестированием методом белого ящика. Тестируемое ПО собирается со специальными настройками или библиотеками и/или запускается в особом окружении, в результате чего для каждой используемой (выполняемой) функции программы определяется местонахождение этой функции в исходном коде. Этот процесс позволяет разработчикам и специалистам по обеспечению качества определить части системы, которые, при нормальной работе, используются очень редко или никогда не используются (такие как код обработки ошибок и т.п.). Это позволяет сориентировать тестировщиков на тестирование наиболее важных режимов.
Тестировщики могут использовать результаты теста покрытия кода для разработки тестов или тестовых данных, которые расширят покрытие кода на важные функции.
Как правило, инструменты и библиотеки, используемые для получения покрытия кода, требуют значительных затрат производительности и/или памяти, недопустимых при нормальном функционировании ПО. Поэтому они могут использоваться только в лабораторных условиях.
Цитаты
«Тестирование программ может использоваться для демонстрации наличия ошибок, но оно никогда не покажет их отсутствие.» — Дейкстра, 1970 г.


Итеративная разработка
Итеративная модель разработкиИтеративный подход (англ. iteration, «повторение») в разработке программного обеспечения — это выполнение работ параллельно с непрерывным анализом полученных результатов и корректировкой предыдущих этапов работы. Проект при этом подходе в каждой фазе развития проходит повторяющийся цикл: Планирование — Реализация — Проверка — Оценка (англ. plan-do-check-act cycle).
Преимущества итеративного подхода:
снижение воздействия серьёзных рисков на ранних стадиях проекта, что ведет к минимизации затрат на их устранение;
организация эффективной обратной связи проектной команды с потребителем (а также заказчиками, стейкхолдерами) и создание продукта, реально отвечающего его потребностям;
акцент усилий на наиболее важные и критичные направления проекта;
непрерывное итеративное тестирование, позволяющее оценить успешность всего проекта в целом;
раннее обнаружение конфликтов между требованиями, моделями и реализацией проекта;
более равномерная загрузка участников проекта;
эффективное использование накопленного опыта;
реальная оценка текущего состояния проекта и, как следствие, большая уверенность заказчиков и непосредственных участников в его успешном завершении.
затраты распределяются по всему проекту, а не группируются в его конце[1].
Пример реализации итеративного подхода — Rational Unified Process.
Спиральная модель
Спира́льная модель, предложенная Барри Боэмом в 1986 году, стала существенным прорывом в понимании природы разработки ПО. Она представляет собой процесс разработки программного обеспечения, сочетающий в себе как проектирование, так и постадийное прототипирование с целью сочетания преимуществ восходящей и нисходящей концепции, делающая упор на начальные этапы жизненного цикла: анализ и проектирование. Отличительной особенностью этой модели является специальное внимание рискам, влияющим на организацию жизненного цикла. Боэм формулирует десять наиболее распространённых (по приоритетам) рисков:
Дефицит специалистов.
Нереалистичные сроки и бюджет.
Реализация несоответствующей функциональности.
Разработка неправильного пользовательского интерфейса.
«Золотая сервировка», перфекционизм, ненужная оптимизация и оттачивание деталей.
Непрекращающийся поток изменений.
Нехватка информации о внешних компонентах, определяющих окружение системы или вовлечённых в интеграцию.
Недостатки в работах, выполняемых внешними (по отношению к проекту) ресурсами.
Недостаточная производительность получаемой системы.
«Разрыв» в квалификации специалистов разных областей знаний.
Большая часть этих рисков связана с организационными и процессными аспектами взаимодействия специалистов в проектной команде.
Каждый виток спирали соответствует созданию фрагмента или версии программного обеспечения, на нем уточняются цели и характеристики проекта, определяется его качество и планируются работы следующего витка спирали. Таким образом углубляются и последовательно конкретизируются детали проекта и в результате выбирается обоснованный вариант, который доводится до реализации. Каждый виток разбит на 4 сектора:
оценка и разрешение рисков,
определение целей,
разработка и тестирование,
планирование.
На каждом витке спирали могут применяться разные модели процесса разработки ПО. В конечном итоге на выходе получается готовый продукт. Модель сочетает в себе возможности модели прототипирования и водопадной модели. Разработка итерациями отражает объективно существующий спиральный цикл создания системы. Неполное завершение работ на каждом этапе позволяет переходить на следующий этап, не дожидаясь полного завершения работы на текущем. При итеративном способе разработки недостающую работу можно будет выполнить на следующей итерации. Главная задача — как можно быстрее показать пользователям системы работоспособный продукт, тем самым активизируя процесс уточнения и дополнения требований. Основная проблема спирального цикла — определение момента перехода на следующий этап. Для ее решения необходимо ввести временные ограничения на каждый из этапов жизненного цикла. Переход осуществляется в соответствии с планом, даже если не вся запланированная работа закончена. План составляется на основе статистических данных, полученных в предыдущих проектах, и личного опыта разработчиков. Одним из возможных подходов к разработке программного обеспечения в рамках спиральной модели жизненного цикла является получившая в последнее время широкое распространение методология быстрой разработки приложений RAD (Rapid Application Development). Под этим термином обычно понимается процесс разработки программного обеспечения, содержащий 3 элемента:
небольшую команду программистов (от 2 до 10 человек);
короткий, но тщательно проработанный производственный график (от 2 до 6 месяцев);
повторяющийся цикл, при котором разработчики, по мере того, как приложение начинает обретать форму, запрашивают и реализуют в продукте требования, полученные через взаимодействие с заказчиком.
Жизненный цикл программного обеспечения по методологии RAD состоит из четырёх фаз:
фаза определения требований и анализа;
фаза проектирования;
фаза реализации;
фаза внедрения.
Спиральная модель ориентирована на большие, дорогостоящие и сложные проекты. В условиях, когда бизнес цели таких проектов могут измениться, но требуется разработка стабильной архитектуры, удовлетворяющей высоким требованиям по нагрузке и устойчивости, имеет смысл применение Spiral Architecture Driven Development. Данная методология, включающая в себя лучшие идеи спиральной модели и некоторых других, позволяет существенно снизить архитектурные риски, что является немаловажным фактором успеха при разработке крупных систем.
Каскадная модель
Каскадная модель (англ. waterfall model) — модель процесса разработки программного обеспечения, в которой процесс разработки выглядит как поток, последовательно проходящий фазы анализа требований, проектирования, реализации, тестирования, интеграции и поддержки. В качестве источника названия часто указывают статью, опубликованную У. У. Ройсом (W. W. Royce) в 1970 году; забавно, что сам Ройс использовал итеративную модель разработки.
Содержание модели
В 1970 году в своей статье Ройс описал в виде концепции то, что сейчас принято называть «каскадная модель», и обсуждал недостатки этой модели. Там же он показал как эта модель может быть доработана до итеративной модели.
В оригинальной каскадной модели Ройса, следующие фазы шли в таком порядке:
Определение требований
Проектирование
Конструирование (также «реализация» либо «кодирование»)
Воплощение
Тестирование и отладка (также «верификация»)
Инсталляция
Поддержка
Следуя каскадной модели, разработчик переходит от одной стадии к другой строго последовательно. Сначала полностью завершается этап «определение требований», в результате чего получается список требований к ПО. После того как требования полностью определены, происходит переход к проектированию, в ходе которого создаются документы, подробно описывающие для программистов способ и план реализации указанных требований. После того как проектирование полностью выполнено, программистами выполняется реализация полученного проекта. На следующей стадии процесса происходит интеграция отдельных компонентов, разрабатываемых различными командами программистов. После того как реализация и интеграция завершены, производится тестирование и отладка продукта; на этой стадии устраняются все недочёты, появившиеся на предыдущих стадиях разработки. После этого программный продукт внедряется и обеспечивается его поддержка — внесение новой функциональности и устранение ошибок.
Тем самым, каскадная модель подразумевает, что переход от одной фазы разработки к другой происходит только после полного и успешного завершения предыдущей фазы, и что переходов назад либо вперёд или перекрытия фаз — не происходит.
Тем не менее, существуют модифицированные каскадные модели (включая модель самого Ройса), имеющие небольшие или даже значительные вариации описанного процесса.
Критика каскадной модели и гибридные методологические решения
Методику «Каскадная модель» довольно часто критикуют за недостаточную гибкость и объявление самоцелью формальное управление проектом в ущерб срокам, стоимости и качеству.[1] Тем не менее, при управлении большими проектами формализация часто являлась очень большой ценностью, так как могла кардинально снизить многие риски проекта и сделать его более прозрачным. Поэтому даже в PMBOK 3-ей версии формально была закреплена только методика «каскадной модели» и не были предложены альтернативные варианты, известные как итеративное ведение проектов.
Начиная с PMBOK 4-ой версии удалось достичь компромисса между методологами, приверженными формальному и поступательному управлению проектом, с методологами, делающими ставку на гибкие итеративные методы.[2] Таким образом, начиная с 2009 года, формально Институтом Проектного Менеджмента (PMI) предлагается как стандарт гибридный вариант методологии управления проектами, сочетающий в себе как плюсы от методики «Водопада», так и достижения итеративных методологов.
V-Model
V-Model (или VEE модель) является моделью разработки информационных систем (ИС), направленной на упрощение понимания сложностей, связанных с разработкой систем. Она используется для определения единой процедуры разработки программных продуктов, аппаратного обеспечения и человеко-машинных интерфейсов.
Обзор
История
Концепция V-образной модели была разработана Германией и США в конце 1980-х годов независимо друг от друга:
Немецкая V-модель была разработана аэрокосмической компанией IABG в Оттобрунне рядом с Мюнхеном в содействии с Федеральным департаментом по закупке вооружений в Кобленце, для Министерства обороны Германии. Модель была принята немецкой федеральной администрацией для гражданских нужд летом 1992.[1]
Американская V-Model (VEE) была разработана национальным советом по системной инженерии (международным — с 1995 года) для спутниковых систем, включая оборудование, программное обеспечение и взаимодействие с пользователями.[2]
Современной версией V-Model является V-Model XT, которая была утверждена в феврале 2005 года. V-модель используется для управления процессом разработки программного обеспечения для немецкой федеральной администрации. Сейчас она является стандартом для немецких правительственных и оборонных проектов, а также для производителей ПО в Германии. V-Model представляет собой скорее набор стандартов в области проектов, касающихся разработки новых продуктов. Эта модель во многом схожа с PRINCE2 и описывает методы как для проектного управления, так и для системного развития.
Основные принципы
Основной принцип V-образной модели заключается в том, что детализация проекта возрастает при движении слева направо, одновременно с течением времени, и ни то, ни другое не может повернуть вспять. Итерации в проекте производятся по горизонтали, между левой и правой сторонами буквы.
Применительно к разработке информационных систем V-Model — вариация каскадной модели, в которой задачи разработки идут сверху вниз по левой стороне буквы V, а задачи тестирования — вверх по правой стороне буквы V. Внутри V проводятся горизонтальные линии, показывающие, как результаты каждой из фаз разработки влияют на развитие системы тестирования на каждой из фаз тестирования. Модель базируется на том, что приемо-сдаточные испытания основываются, прежде всего, на требованиях, системное тестирование — на требованиях и архитектуре, комплексное тестирование — на требованиях, архитектуре и интерфейсах, а компонентное тестирование — на требованиях, архитектуре, интерфейсах и алгоритмах.[4]
Цели
V-модель обеспечивает поддержку в планировании и реализации проекта. В ходе проекта ставятся следующие задачи:
Минимизация рисков: V-образная модель делает проект более прозрачным и повышает качество контроля проекта путём стандартизации промежуточных целей и описания соответствующих им результатов и ответственных лиц. Это позволяет выявлять отклонения в проекте и риски на ранних стадиях и улучшает качество управления проектов, уменьшая риски.
Повышение и гарантии качества: V-Model — стандартизованная модель разработки, что позволяет добиться от проекта результатов желаемого качества. Промежуточные результаты могут быть проверены на ранних стадиях. Универсальное документирование облегчает читаемость, понятность и проверяемость.
Уменьшение общей стоимости проекта: Ресурсы на разработку, производство, управление и поддержку могут быть заранее просчитаны и проконтролированы. Получаемые результаты также универсальны и легко прогнозируются. Это уменьшает затраты на последующие стадии и проекты.
Повышение качества коммуникации между участниками проекта: Универсальное описание всех элементов и условий облегчает взаимопонимание всех участников проекта. Таким образом, уменьшаются неточности в понимании между пользователем, покупателем, поставщиком и разработчиком.[5]
Достоинства
Пользователи V-Model участвуют в разработке и поддержке V-модели. Комитет по контролю за изменениями поддерживает проект и собирается раз в год для обработки всех полученных запросов на внесение изменений в V-Model.[6]
На старте любого проекта V-образная модель может быть адаптирована под этот проект, так как эта модель не зависит от типов организаций и проектов.[7]
V-model позволяет разбить деятельность на отдельные шаги, каждый из которых будет включать в себя необходимые для него действия, инструкции к ним, рекомендации и подробное объяснение деятельности.[8]
Ограничения
Следующие моменты не учитываются в V-модели, но могут быть рассмотрены отдельно, либо возможно адаптировать модель под них:
Не регулируется размещение контрактов на обслуживание.
Организация и выполнение управления, обслуживания, ремонта и утилизации системы не учитываются в V-модели. Однако, планирование и подготовка к этим операциям моделью рассматриваются.
V-образная модель больше касается разработки программного обеспечения в проекте, чем всей организации процесса.[9]
Критика
Мнения различных разработчиков о достоинствах и недостатках V-model, не входящих в официальную документацию:
Преимущества
В модели особое значение придается планированию, направленному на верификацию и аттестацию разрабатываемого продукта на ранних стадиях его разработки. Фаза модульного тестирования подтверждает правильность детализированного проектирования. Фазы интеграции и тестирования реализуют архитектурное проектирование или проектирование на высшем уровне. Фаза тестирования системы подтверждает правильность выполнения этапа требований к продукту и его спецификации.[10]
В модели предусмотрены аттестация и верификация всех внешних и внутренних полученных данных, а не только самого программного продукта.[10][11][12]
В V-образной модели определение требований выполняется перед разработкой проекта системы, а проектирование ПО — перед разработкой компонентов.[10]
Модель определяет продукты, которые должны быть получены в результате процесса разработки, причем каждые полученные данные должны подвергаться тестированию.[10][12]
Благодаря модели менеджеры проекта могут отслеживать ход процесса разработки, так как в данном случае вполне возможно воспользоваться временной шкалой, а завершение каждой фазы является контрольной точкой.[10][12]
Недостатки
Модель не предусматривает работу с параллельными событиями.[10]
В модели не предусмотрено внесение требования динамических изменений на разных этапах жизненного цикла.[10][11][13]
Тестирование требований в жизненном цикле происходит слишком поздно, вследствие чего невозможно внести изменения, не повлияв при этом на график выполнения проекта.[10][11]
В модель не входят действия, направленные на анализ рисков.[10]
Некоторый результат можно посмотреть только при достижении низа буквы V.[14]
Dual Vee Model
Dual Vee Model основывается на V-модели, чтобы показать сложности, связанные с проектированием и разработкой систем.
В системотехнике она определяет единый порядок разработки продукта или проекта. Модель изображает одновременное развитие архитектуры системы как одной V-модели с каждым объектом этой архитектуры как другую V модель, которая пересекает архитектуру V модели. Это явно показывает взаимодействия и последовательности в разработке сложных систем и систем систем.
Предпосылка
Модель водопада
Модель Водопада разбивает процесс разработки на разработку фаз. Название подразумевает, что проектные решения вытекают из требований, реализация вытекает из проекта и т. д. В большом проекте много различных людей работают только над определёнными частями проекта. Так проектировщик может спросить: «Что я пытаюсь спроектировать?» и ответ может быть: «Вы пытаетесь спроектировать что-то, что будет удовлетворять требованиям к продукту.» Разработчик может спросить: «Что я пытаюсь разработать?» и ответ может быть: «Вы пытаетесь разработать то, что было спроектировано.» и т. п.
V-Model
V-модель организует фазы разработки исходя из уровня сложности, где наиболее сложный пункт будет вверху, а самый простой — внизу (также известный как Самый нижний пункт конфигурации).
Это ставит требования в начало рядом с функционированием продукта в конце и проектирование рядом с проверкой. Это имеет смысл, так как когда разработчик поставляет продукт клиенту, клиент может спросить: «Почему я должен принять этот продукт?» и разработчик должен ответить: «Потому что он отвечает вашим (клиентским) требованиям». Требования связаны с функционированием. При выполнении тестирования продукта, инженер-тестировшик может спросить: «Какие тесты я должен провести?» и проектировщик должен ответит: «Вы должны провести тесты, чтобы показать продукт, который был построен в соответствии с проектом.» Проверка связана с проектом. V-модель может быть расширена в нескольких направлениях для удовлетворения системных требований. Это может включать в себя семь INCOSE слоев сложности системы (например система, элемент, подсистема, сборка, подсборка, компонент и часть). Это может включать в себя разбиение, определение, интеграцию и проверку. Также это может включать участие пользователей/заинтересованных сторон, управление рисками и решения проблем.
Dual Vee Model
Двойная V модель основывается на V модели для управления системой систем. Архитектура V управляет системой и набором ветвей V модели исходящих из V архитектуры для управления подсистемами. Например, GPS включает в себя совокупность спутников, наземную сеть управления и миллионы пользователей по всему миру. Каждый спутник, наземный центр управления и GPS приёмник представляют собой сложную систему, которая может находиться под управлением отдельного объекта V модели. Разработка спутника может повлиять на проектирование, производство или стоимость приёмников. Подобно разработка приёмника может повлиять на проект, производство и стоимость спутников. Так что всё должно быть интегрировано в систему систем, которая разрабатывается в рамках более крупной Vee Архитектуры.
Vee Архитектура
При разработке сложных систем, системный инженер должен управлять итоговой конфигурацией системы от начала и до конца. Итоговая конфигурация может включать проектную документацию, руководства по эксплуатации, сам продукт и должна отвечать на вопросы Что, Почему? и Кто? по архитектуре системы. На каждой фазе разработки будут изменения в системе, которые приведут к изменению итоговой конфигурации. Ядро Vee является разивающаюся модель от начальных требований к готовой системе. Vee Архитектура отвечает на вопросы что, почему и кто (какой уровень системы) отвечает за архитектуру системы. Нисходящие из V ядра исследования усиливают процесс получения знаний для подтверждения итоговых архитектурных решений сделанных в ядре V. Восходящие из ядра взаимодействия с клиентами и пользователями усиливают поэтапное подтверждение поддерживая вовлечённость заинтересованных лиц в конечном продукте. Необходимо обратить внимание на то, что во всех V моделях представление времени и завершённости продукта движется слева направо. Так же как мы не можем перемещаться назад во времени, также мы не можем двигаться справа налево в V моделях. Последовательное приближение — это основное в разработке системы и все шаги делаются вертикально от ядра, вверх к пользователям и клиентам (что есть поэтапное подтверждение) и вниз к управлению рисками и новыми возможностями.
Левая ветвь Vee ядра сосредоточена вокруг того, какая концепция лучше и какая архитектура лучше для этой концепции. Например, коммерческие продукты обычно сталкиваются с дилеммой: батареи должны быть стандартными, уникальными, заменяемые или нет нисходящие из V ядра исследования и анализы могут ускорить определение наиболее желательного метода, который мог бы быть позже зафиксирован на V ядре если все заинтересованные лица согласны. Подобные исследования могут доказать жизнеспособность и технические возможности варианта концепции. Правая ветвь V ядра нисходящих исследований управляется на уровне исследования интеграционных аномалий для определения причин и устранения их. Восходящие взаимодействия с заинтересованными лицами определяют, согласны ли они с такой интеграцией и выполненной проверкой.
На каждом представленном уровне существует прямая связь между действиями с левой и правой стороны V модели. Это сделано преднамеренно. Например, метод интеграции, проверки и утверждения которые будут использоваться в правой части должны быть определены в левой части также как концепции, определённые на каждом из уровней. Это минимизирует вероятность того, что концепции задуманы таким образом, что их невозможность осуществить.
Структура V модели
Структура V модели показывает её разработку и реализацию, процесс который описывает как каждый объект будет получен (разработан, приобретён, повторно использован и т. д.) Модель Vee существует для каждого объекта архитектуры начиная с уровня системы вниз до уровня мельчайших конфигурационных элементов (LCI), такие как элементы компьютерного обеспечения или микросхемы. Все действия внутри объекта Vee находятся на том же самом уровне архитектура (Система, Подсистема, LCI). Левая ветвь Vee представляет определение модели, её развитие от черновых требований клиента, через определение концепции и до описания решения и полностью построенного образца. Правая ветвь Vee представляет последовательность сборки объекта и её гарантированная производительность, полученная посредством проверок и утверждений объекта.
В каждой разработке, существует зависимость между действиями на левой и правой ветви Объекта Vee. Это сделано специально. Метод проверки, которые будут использоваться в правой ветви Vee должны быть определены одновременно с разработкой требований на левой ветви, в противном случае могут быть созданы требования, которые не могут быть проверены. Например, «быть дружественным к пользователю» является подходящим требованием, но его проверить невозможно. Вместо этого, требование, которое утверждает что на экране компьютера может быть «не более пяти строк текста, набранным 14 шрифтом текста» определяет один пользовательский критерий требования «быть дружественным к пользователю» в измеримых величинах. План проверок должны быть согласован и зафиксирован чтобы гарантировать, что требования к проверкам и их методы известны и запланированы на этапе принятия решения по разработке, называемого Проверка Предварительного Проекта (Preliminary Design Review (PDR)). Черновые процедуры проверок основанные на требованиях к проверкам, плане проверок, и предложенном проекте объекта должны быть известны на этапе принятия решения по созданию и программированию, обычно называемом Окончательная Оценка Разработки (Critical Design Review (CDR)). Это снижает вероятность того, что проверка, в том виде котором она определена не может, быть выполнена. Вертикальное размер Vee Объекта это зафиксированная разработка на выбранном уровне архитектуры и ядро Vee Объекта представляющее итоговую последовательность разработки объекта. Также включены (по аналогии с Vee Архитектурой) действия, связанные с управлением возможностями и рисками, осуществляемые в нисходящем от ядра объекта направлении до уровня необходимого для оценки и решения проблемы. Например, лабораторные испытания компьютерного чипа или программного обеспечения могут быть необходимы для подтверждения технической пригодности.
В отличие от широко распространённого мнения о Модели Водопада, не существует запрета на выполнение пробной разработки и её анализа в любой точке проектного цикла для исследования или доказательства производительности или пригодности. В отличие от Спиральной Модели, в Vee модели исследования возможностей и рисков могут быть выполнены последовательно или в параллель с основной разработкой, а не проводиться постфактум или до процесса разработки решения. Аппаратные и программные требования понимания моделей или технической пригодности моделей приветствуются в начале проектного цикла для реализации таких возможностей, как новые технологии, и для снижения риска. Например, для оценки концепции ручной корректировки текста в сравнении с полностью автоматической корректировкой, техническая пригодность обоих концепций может быть смоделирована и выбор может быть сделан на основе сравнения времени и стоимости решений. Согласие клиента может также обеспечить необходимое в проектном цикле утверждение более предпочтительного метода.
В правой ветви, нисходящие от основного процесса запросы применяются для выполнения сбора и проверки отклонений. Это может подразумевать происходящие от проекта ошибки, дефекты при пайке или ошибка оператора и тому подобное. Восходящие от основного процесса пользовательские взаимодействия — получении пользовательского или клиентского подтверждения или отказ от достигнутых результатов. Обратите внимание на то, что в объекте Vee эти взаимодействия указывают на индивидуальные решения в модели, а не на интегрированную архитектуру, выполненную на Vee архитектуре. На любом уровне представленной модели клиент модели в то же время является управляющим нескольких более высоких уровней модели. Например, человек, управляющий подсистемой электропитания, является клиентом на уровне зарядных батарей, и он выполняет приёмку этих самых батарей.
Двойная Vee: Перекрещивающаяся архитектура и Модели Vee
Чтобы выявить то, что необходимо пользователю в системе, что удовлетворяет эти пользовательские потребности, требуется наиболее ценное решение для каждого объекта архитектуры. Это можно продемонстрировать наглядно, расположив Vee-объекты перпендикулярно к архитектуре Vee. Для каждого объекта архитектуры Vee существует соответствующий объект Vee, который определяет развитие и исполнение объекта.
Распределение точек принятия решения
Архитектурные объекты разрабатываются и интегрируются в архитектуру системы в заранее определённой последовательности в соответствии с лучшими примерами системной инженерии.
Для упрощения картины только один объект Vee показан пересекающим архитектуру Vee на каждом уровне. Обратите внимание, что последовательность разработки указана сверху вниз, начиная с системного уровня и продолжающаяся последовательно со схемой до нижнего уровня конфигурации составных частей (LCI). Эта последовательность гарантирует, что существуют соответствующие требования, которые сохраняются от начала до конца и которые можно легко отследить.
Когда образец для разработки и программирования, включающий черновую процедуру проверки, готов быть зафиксированным, последовательность принятия решения по разработке выполняется снизу вверх, чтобы доказать пригодность разработки или программного кода. Точка принятия решения также подтверждает что если окончательное решение будет построено в соответствии с разработанным образцом, требуемая производительность будет достигнута. Эта последовательность гарантирует что если проекты объекта удовлетворяют требованиям принятым на этапе принятия решения по разработке, объекты будут интегрированы в следующий более высокий уровень объекта, будут реализованы как ожидалось и будут отвечать пользовательским требованиям.