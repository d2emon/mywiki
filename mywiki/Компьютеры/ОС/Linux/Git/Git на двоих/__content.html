<!DOCTYPE html>
<HTML>
<HEAD>
	<META HTTP-EQUIV='CONTENT-TYPE' CONTENT='TEXT/HTML; CHARSET=UTF-8'/>

	<STYLE type="text/css">
		body, div, p, table {
			font-size:10pt;
			font-family:Verdana;
		}

		img{border:none}
		
	</STYLE>
	
</HEAD>

<BODY>
<P>
<H1>Git на двоих</H1></P>

<P>Одной из самых полезных технических средств организации труда в команде является система контроля версий.</P>

<P>С ней у вас есть возможность всегда вернуться к предыдущей версии (если текущая окажется с критическими ошибками), возможность для разработчиков свободно работать со своей копией продукта асинхронно и потом эти копии без проблем сливать в финальную версию, разделять работу над разными функциями и потом бросить разработку какой-либо из них, не затронув остальные, либо же легко внедрить её в основную нить разработки.</P>

<P>Вообще говоря, если вы ещё не пробовали использовать никакую систему контроля версий, вы не умеете работать в команде.</P>

<P>Мы в своё время остановились на Git среди прочих, и вот по каким причинам:</P>

<P>
<UL>
<LI>Не нужно выделенного сервера для репозитория.</LI>
</UL>В условиях не безграничных вычислительных ресурсов очень приятно, что не требуется выделять память, процессорное время и собственное внимание лишнему сервису.</P>

<P>
<UL>
<LI>Удобное ветвление и смешивание.</LI>
</UL>Часто бывает необходимо попробовать новую возможность, не ломая стабильный код (и продолжая его развивать параллельно). С Git’ом создавать и смешивать не сможет научиться только очень ленивый. Вы можете с лёгкостью поддерживать несколько параллельных нитей развития кода, смешивая их по необходимости.</P>

<P>
<UL>
<LI>Лёгкое взаимодействие между репозиториями.</LI>
</UL>Также, как и с локальными ветками, работа с удалёнными очень проста.</P>

<P>
<UL>
<LI>Логичность.</LI>
</UL>Если вы всерьёз попробуете использовать Git (а вы когда-нибудь это обязательно сделаете, по своему желанию или нет), заметите, что некоторые вещи настолько самоочевидные и логичные, что их отсутствие в других системах контроля версий кажется ужасно нелепым.</P>

<P>Цель данной статьи — показать на конкретных маленьких примерах, как можно использовать Git в команде из двух человек.</P>

<P>Общая схема такая: есть центральный репозиторий на сервере, с которого происходит deploy продукта, отдельные разработчики ведут локальные зеркала, периодически синхронизируя их с сервером.</P>

<P>
<H2>1. Создание репозитория</H2></P>

<P>Всё просто. Репозиторий = каталог. Доступ к нему можно получить по множеству протоколов, при этом меньше всего настройки требуется в случае ssh (так как он уже настроен на любом сервере). Выполните следующие команды на сервере.</P>

<P><CODE>
<BR>mkdir Project
<BR>cd Project
<BR>git init
<BR></CODE></P>

<P>Готово.</P>

<P>
<H2>2. Клонирование репозитория</H2></P>

<P>Каждый из разработчиков должен создать себе локальную копию. Делается это очень просто.</P>

<P><CODE>
<BR>git clone ssh://server.example.com/path/to/Project
<BR>server.example.com — имя вашего сервера
<BR></CODE></P>

<P>
<H2>3. Внесение изменений</H2></P>

<P>Мелкие поправки вносятся простым коммитом с последующим закидыванием изменений на сервер.</P>

<P><CODE>
<BR>git add ...
<BR>git status
<BR>git commit -m "Commit message"
<BR></CODE></P>

<P>Первой команде в качестве аргументов следует указать имена добавляемых файлов. Следует заметить, что для git’а изменённый файл является новым объектом. Поэтому для того, чтобы обновить файл в репозитории, также как и добавить новый файл, следует выполнить для него git add перед коммитом.</P>

<P>git status наглядно покажет состояние файлов вашего дерева (неизвестные системе файлы, изменённые, не изменённые, находящиеся в конфликте и т.д.)</P>

<P>Серьёзную работу следует вести в отдельных ветвях для облегчения процесса смешивания нитей разработки обоих участников процесса.</P>

<P><CODE>
<BR>git branch new-feature
<BR>git checkout new-feature
<BR>...сделать что-нибудь...
<BR>git add ...
<BR>git commit -m "Commit message"
<BR></CODE></P>

<P>Первыми двумя командами мы создали новую ветвь и обновили дерево (то есть переписали файлы в каталоге их версиями из новой ветви; в данном случае, на самом деле, ничего не изменится, новая ветвь пока копия основной ветви master, но в будущем вы можете легко переключаться между ветвями командой checkout, при этом дерево файлов будет соответствующим образом обновляться).</P>

<P>Структуру ветвей можно посмотреть в виде красивого графа командой gitk (она же даёт и другую полезную информацию).</P>

<P>Команда git branch покажет, что у нас две ветви: master и new-feature. Командой checkout можно переключаться между ними (и делать затем коммиты в каждую, не затрагивая другую). Когда вы закончите разрабатывать новую возможность, настанет время примешать изменения в основную ветвь, master.</P>

<P><CODE>
<BR>git checkout master
<BR>git merge new-feature
<BR></CODE></P>

<P>Если изменения не могут быть примешаны автоматически (например, в каком-то файле в ветви master одна из строк изменилась иным образом, чем в ветви new-feature), следует использовать ключ -s resolve у команды merge:</P>

<P><CODE>
<BR>git merge -s resolve new-feature
<BR>...увидите, какие файлы находятся в состоянии конфликта...
<BR>...отредактируете файлы нужным образом...
<BR>git commit -a -m "Merged new-feature"
<BR></CODE></P>

<P>Обратите внимание, что в первом случае коммит создаётся автоматически, во втором же вручную, после устранения конфликтов. Ещё можно заметить полезный ключ у команды commit: -a. Это равносильно тому, чтобы сделать git add для всех уже известных git’у файлов (то есть тех, чьи старые версии есть в репозитории).</P>

<P>
<H2>4. Отправка изменений и приём изменений основной ветки (master)</H2></P>

<P>Итак, у нас в ветви master имеются изменения, которые неплохо бы отдать своему коллеге (ну и выложить на сервер с целью последующего deploy’а новой версии).</P>

<P><CODE>
<BR>git push origin
<BR></CODE></P>

<P>Всё. Изменения внесены.</P>

<P>Чтобы получить изменения, следует сделать</P>

<P><CODE>
<BR>git pull origin
<BR></CODE></P>

<P>В некоторых случаях изменения с сервера невозможно автоматически добавить в вашу ветвь master, тогда вместо pull’a следует использовать merge:</P>

<P><CODE>
<BR>git merge origin/master
<BR></CODE></P>

<P>...или, в плохом случае...</P>

<P><CODE>
<BR>git merge -s resolve origin/master
<BR></CODE></P>

<P>Откуда взялся origin? Это имя удалённого репозитория, автоматически добавленное командой git clone. Источник клонирования. Ваш тот самый сервер из первого пункта, как вы уже догадались. Можно добавить другие удалённые репозитории</P>

<P><CODE>
<BR>git remote add second-server ssh://second.example.com/path/to/repo
<BR></CODE></P>

<P>Формат команды очевиден. Все remote-репозитории одинаковы, origin не является чем-то особенным. Просто его создали автоматически :-)</P>

<P>В нашем случае сервер лишь один, поэтому работа с remote рассматриваться далее не будет.</P>

<P>
<H2>5. Обмен изменениями без затрагивания ветки master</H2></P>

<P>В обычных конфигурациях предполагается, что, если на сервер в ветку master что-то попало, то его можно сразу выкладывать в production.</P>

<P>Что же делать, если вы не хотите затрагивать master, а хотите обменяться какими-то наработками в других ветвях?</P>

<P>Ничего сложного.</P>

<P><CODE>
<BR>git checkout new-feature
<BR>git merge origin/new-feature
<BR>...сделать что-нибудь...
<BR>git push origin new-feature:new-feature
<BR></CODE></P>

<P>Последняя команда отправит на сервер лишь ветку new-feature (последний аргумент показывает, что локальная ветка new-feature будет отправлена в удалённую ветку new-feature, в общем случае их названия не обязательно должны совпадать).</P>

<P>
<H2>6. Что дальше?</H2></P>

<P>Собственно, это вся база, что требуется для начала использования Git’a.</P>

<P>Подробные разъяснения формата команд и их действия вы можете получить, набрав git command –help.</P>
</BODY>
</HTML>