!! Про Linux — для любознательных Windows-пользователей

Так уж получилось, что даже на Хабре многие имеют очень смутное представление о семействе OS Linux.

Цель данной статьи – максимально популярным языком рассказать про особенности и отличия Linux от Windows для тех, кто вообще не имел с ним дела.

Я уже не один год свободно пользуюсь Archlinux, загружая винду лишь «на поиграться». Данная статья рассказывает о вещах, которые я выяснил эмпирическим путем, тыкаясь словно слепой котенок. Если бы в свое время мне попалась бы именно такая информация именно в такой форме — это сэкономило бы мне как минимум 2 года, в течение которых я переходил с Windows на Linux.

Почти цитата с люркмора:

Краеугольный принцип работы с linux-системами — “От понимания – к действию”, в то время как в Windows — “Знаю куда нажать/где поставить галочку – делаю”. Говоря другими словами, чтобы что-то сделать – необходимо понимать, как оно там, внутри, устроено.

!!! Тезис №1 – НЕОБХОДИМО владеть работой с системой из текстовой консоли!


“Чистый” линукс (базовая система) в любом дистрибутиве выглядит как DOS – черный экран, текстовый режим, мигающий курсор ожидает ввода. Когда сталкиваешься с таким впервые – сидишь и думаешь: “Блин, а что писать-то?”.

Современные user-friendly дистрибутивы дарят иллюзию, что пользователю консоль не нужна. Добрые дяди, мол, уже обо все позаботились. Вот тебе обоина в FullHD-разрешении, вот программа для настройки параметров – знай расставляй галочки, все как в Windows… Чтобы избежать ненужных холиваров, сделаю на этом месте отступление.

Есть пользователи Linux, у которых никогда ничего не глючит. Ubuntu обновляется с одной мажорной версии на другую, причем начиная с Ubuntu 1.0, и так далее. Ребята, не пишите ничего в комментариях про ненужность консоли для пользователя, идите лучше полюбуйтесь на радугу, которой какают розовые пони в вашем мире.

В моем мире Linux глючит и ломается. Нет, все вполне окей, если ты просто запускаешь программы и пользуешься ими. Но потом вдруг наступает момент, когда тебе позарез надо, скажем, сменить открытые дрова на проприетарные… ну или просто обновить систему. И вот тут, если звезды встали неудачно, ты получаешь сломанную систему и текстовую консоль как единственный метод взаимодействия с ней. И (что самое поганое) – подобная фигня имеет свойство случаться регулярно. 

Мой опыт говорит о том, что в такие моменты Windows-пользователь действует так, как он привык, повинуясь привычной идеологии. Сначала идет попытка “починить”. Windows-идеология предписывает найти в инете обсуждение аналогичной проблемы и ее решение, после чего повторить все действия, которые привели к решению проблемы. Итог – пользователь бездумно вбивает непонятные ему команды. Иногда это даже помогает, чаще – нет: содержимое команд необходимо модифицировать под конкретные условия и конкретную локальную машину, а знаний для этого нет. Как следствие, дальнейшим логическим шагом идет переустановка системы. Поверьте, я знаю о чем говорю – я сломал и переустановил Ubuntu более 10 раз… из которых около трети после самопроизвольной смерти системы в процессе обновления, без корелляции с кривизной рук.

Изучение устройства системы и работы с ней из консоли сроди известному “день потерять – за час долететь”. Устранить проблему в этом случае – гораздо быстрее переустановки, не говоря уже о том, что куда проще становится “не ломать” :) Кроме того, полностью исчезает разница – сидишь за компьютером локально или через удаленную SSH-сессию. Поверьте, это ощущение многого стоит.

!!! Тезис №2: user-friendly дистрибутивы для изучения системы подходят плохо.


Разработчики подобных дистрибутивов старательно создают интерфейсный графический слой, призванный свести взаимодействие пользователя и системы до бездумного кликанья мышкой. Технически же этот слой может представлять из себя совершенно феерическое нагромождение костылей – на bash'е, python'е, perl'е… совершеннейший ад для новичка, пытающегося понять логику работы системы. Кроме того, вменяемая документация (если она вообще есть) теряется среди форумных постов вида “чтобы получить А, введите в консоли Б, а в настройках нажмите кнопочку С”

Для обучения лучше всего подходят технически минималистичные дистрибутивы с качественной и подробной документацией. Таковыми, к примеру, являются Gentoo и Archlinux. Лично я рекомендую последний – просто потому, что в моем случае это сработало. После пары лет мытарств с Убунтой, всего пара месяцев с Арчем продвинула меня в постижении Linux раз в 10 дальше.

Причин тут несколько:

* Технический минимализм системы сильно облегчает ее понимание.
* Качественная, подробная документация облегчает процесс обучения.
* Выход из “зоны графического комфорта” весьма способствует!

Последний пункт стоит отметить особо. Ubuntu с ее графическим интерфесом никак не добавляет мотивации ковыряться в консоли. Другое дело – когда изначально есть лишь консоль и сильнейшая мотивация “настроить уже этот графический интерфейс” — тут просто деваться некуда, приходится осваивать документацию и обрастать знаниями.

!!! Windows и Linux: принципиальные отличия

# Файловая система
** В Linux логическим дисковым томам не назначаются буквы. Вместо этого один из них назначается корневым, а остальные подключаются к указанным папкам внутри него. Все пути начинаются с косой черты, без всяких дисков C:
** Все системные файлы свалены в корневой файловой системе, и разбиты по каталогам по типам/назначению. Условно говоря, все настройки находятся в /etc, исполняемые файлы в /bin и /usr/bin – и ко всему этому добру обычный пользователь (не администратор) имеет доступ только на чтение/выполнение, и то не всегда (когда дело касается системных сервисов)
** Расширения у файлов в linux – вещь совершенно необязательная. Является ли файл исполняемым, определяется специальной отметкой – по типу отметки “скрытый” или “архивный” в Windows. Исполняемые файлы без расширения в linux – норма вещей!
** В linux нет специальной отметки того, что файл скрытый. Вместо этого используются имена с точкой в начале, а уже файловые менеджеры позволяют отключать отображение таких файлов. То есть, файл /home/user/.bashrc – скрытый. Точка в этом случае – часть имени файла!
** Обычный пользователь имеет полный доступ только к своей личной папке, которая обычно находится в /home/%имя_пользователя%. По аналогии с диском D: в Windows, к папке /home часто подключают отдельный раздел диска. Таким образом, все данные пользователей находятся на отдельном разделе (или вообще физическом жестком диске).
** Все пользовательские (не системные) программы при необходимости сохранить какие-то свои данные или настройки, делают это только в домашней папке пользователя, от которого они запущены – просто потому, что только в ней они имеют право на запись.
** Само понятие “файл” в Linux немного другое, более широкое. Есть т.н. “файлы устройств”. Например, /dev/sda обычно жесткий диск (хотя может быть и флешка), а /dev/sda1 это первый раздел этого жесткого диска. Отсюда возможны такие хитрые маневры, как dd if=/dev/sda1 of=/home/user/backup – команда побайтно скопирует весь первый раздел диска /dev/sda в файл backup в домашнем каталоге пользователя. Есть т.н. “символьные ссылки” — в файловом менеджере они выглядят как обычный файл, по факту ссылаются на другой файл, и места на диске не занимают. То есть, может быть один исполняемый файл и куча символьных ссылок на него в разных местах.
# Пакетный менеджер и понятие “пакета”, установка программ.
** Программы ставятся только от аккаунта администратора. При установке все файлы, относящиеся к программе (например, Firefox), “размазываются” по корневой файловой системе – общие для всех пользователей настройки пойдут в /etc, исполняемые файлы в /usr/bin, а иконки и различные ресурсы вроде графики и звуков – в /usr/share/firefox. При таком раскладе пользователь в принципе не может знать, где у него что конкретно лежит. За это отвечает пакетный менеджер. Например, пакет “Firefox” включает в себя кучу файлов. Пакетный менеджер при установке пакета разложит их по файловой системе, а при удалении – соответственно удалит.
** Еще одна важная функция пакетного менеджера – удовлетворение зависимостей пакета. Например, Firefox требует для работы библиотеку libjpeg. Значит, при установке менеджер пакетов автоматически доустановит пакет libjpeg, а при удалении – удалит, если тот не будет требоваться каким-либо еще пакетом.
** В пакетном менеджере обычно есть база данных со всеми доступными пакетами, и он имеет средства поиска по этой базе. Поэтому установка программ в linux невероятно проста – первой командой мы ищем по ключевым словам по базе точное название пакета, второй – ставим. Не нужно лезть на сайты, искать и что-то качать. Если мне надо в Арче поставить skype – я набираю pacman -S skype и жму ENTER, и через минуту у меня установлен скайп. Надо Firefox – пишу pacman -S firefox. И так далее. В другом дистрибутиве будет отличаться команда и синтаксис, возможно потребуется указать адрес репозитория – сам принцип неизменен.
** Никогда, никогда даже не пытайтесь качать и запускать что-либо через браузер, как в Windows! Только если вы полностью знаете, что делаете – но тогда зачем вы все это читаете?) Скачать и запустить файл — это часть полностью чуждой (даже враждебной) для Linux идеологии. Программы надо ставить через пакетный менеджер. Точка.
** Никогда не используйте для установки программы метод “configure && make && make install”. Каждый раз, когда это происходит – в мире мучительной смертью умирает с десяток невинных котят. Данный набор команд соберет из исходников программу, а потом раскидает ее файлы по файловой системе без ведома пакетного менеджера. Это нарушение нормальной логики работы с системой. Не делайте так))
** Добавлю, пожалуй, сюда еще вот что. Очень часто можно увидеть настойчивые советы «не работать из под администратора», и на это есть не совсем очевидная Windows-пользователям причина. Дело в том, что набор команды в консоли таит в себе опасность опечаток и случайных нажатий. Вполне реальна ситуация, когда ты собираешься удалить папку, начинаешь писать к ней путь и случайно задеваешь ENTER. Linux не имеет привычки спрашивать «Ты точно такой дурак? y/n» — он просто сделает. Поэтому под рутом набирать команды приходится предельно внимательно. В Windows такой проблемы, конечно, нет.
# Графическое окружение пользователя
** Все графическое окружение пользователя – это совокупность прикладных программ. Исторически сложилось, что для Windows-пользователя такие понятия, как “Рабочий стол”, панель задач, системный трей, регулятор громкости, часы и календарь, меню “Пуск”, доступ к настройкам сети из трея – неотъемлимая часть ОС Windows. В Linux все вышеперечисленное реализуется отдельными программами. Более того, для каждой задачи из приведенного списка есть далеко не одна программа. В качестве регулятора громкости я могу поставить volumeicon, написанный на C, или volwheel на python
** В основе работы графического окружения лежат следующие программы:
### X-сервер, или просто “Иксы”. Программа, осуществляющая прием данных от пользователя (с устройств ввода) и базовое управление окнами, их сворачивание-разворачивание. “Сервером” называется потому, что обеспечивает “сетевую прозрачность”: для Linux не существует разницы, каким образом пользователь зашел в графический сеанс, локально или удаленно. Эдакий RDP как базовая функциональность, проще говоря.
### Менеджер окон, он же WM. Занимается отрисовкой элементов оконного интерфейса, плюс (в зависимости от навороченности) предоставляющий ряд других функций. Некоторые WM позволяют задать фон рабочего стола, некоторые добавляют функциональность “системного меню”. Иногда с X-сервером ставится простейший (чтобы было) менеджер окон – TWM. Страшный как божий грех, прямиком из 70х годов.
### Декоратор окон – иногда функционал по оформлению окон, возможность менять темы оформления выносится в отдельную программу
### Композит-менеджер – тоже бывает как часть WM, либо как отдельная программа. Его задачей является переложить отрисовку интерфейса на видеокарту. Технически принцип прост – каждое отрисованное окно это отдельная текстура в памяти видеокарты. А обращаться с текстурами, добавлять эффекты и искажения, проецировать на плоскость в пространстве, менять полупрозрачность и накладывать их друг на друга видеокарты умеют уже много лет.
### Элементы интерфейса: панель задач, трей, менеджер сети, системное меню, программа для задания обоев рабочего стола
### Базовый прикладной софт – диспетчер файлов, эмулятор терминала (чтобы консольные команды писать в красивом полупрозрачном окошке)
# Преднастроенные ”комплекты” подобранных друг под друга элементов графической среды, программ из списка выше, называются “Окружениями рабочего стола”, или DE. Наиболее известны такие DE, как Gnome и KDE, самые тяжеловесные и “жирные”. Есть также XFCE и LXDE. Установка часто реализуется посредством установки так называемого мета-пакета – сам по себе пакет не содержит файлов, но в качестве зависимостей требует установки всего комплекта программ, составляющих DE: WM, декоратора/композит-менеджера, файлового менеджера и так далее
# Также можно (и нередко является разумным) собирать для себя окружение из “кусочков” по своему вкусу – отдельно выбрать WM, отдельно файл-менеджер и так далее

!!! Подведение итогов

После небольшого самообразования, получение из текстово-консольной системы графической происходит в одну команду. В моем случае, я набираю:

[@
pacman -S xf86-video-ati xorg-server openbox tint2 nitrogen lxterminal xcompmgr wicd-gtk volumeicon.
@]

Это команда установить все перечисленные пакеты:

* xf86-video-ati это open-source драйвера для моей видеокарты
* xorg-server это “иксы”
* openbox это легковесный WM с системным меню (типа как “Пуск”)
* tint2 это панель задач с треем, куда будут сворачиваться приложения
* nitrogen позволяет задать фон рабочего стола
* lxterminal – мой любимый эмулятор терминала
* xcompmgr это самый простой композит-менеджер, добавляет полупрозрачность и тени
* wicd-gtk это менеджер сетевых подключений, который висит в трее
* volumeicon – регулятор громкости

После этого, уже из графической среды, через lxterminal устанавливаю все остальное, что нужно для жизни: браузер(ы), файл-менеджер, видео и аудиокодеки, плеер, libreoffice, gimp и прочее)