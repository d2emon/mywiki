<!DOCTYPE html>
<HTML>
<HEAD>
	<META HTTP-EQUIV='CONTENT-TYPE' CONTENT='TEXT/HTML; CHARSET=UTF-8'/>

	<STYLE type="text/css">
		body, div, p, table {
			font-size:10pt;
			font-family:Verdana;
		}

		img{border:none}
		
	</STYLE>
	
</HEAD>

<BODY>
<P>
<H1>Диалоговые окна в Delphi: руководство для начинающих</H1></P>

<P>С первых шагов в Inprise Delphi программист сталкивается с необходимостью так или иначе привлекать внимание пользователя к событиям внутри приложения или операционной системы - или, еще лучше, выводить диалоговые окна, например, при запросе на сохранение, как это реализовано в старом добром Блокноте. </P>

<P>Добрый дядюшка Borland любезно снабдил нас такой функцией, как beep, заставляющей PC Speaker пищать, - это полезно, например, если юзер начнет тупо набирать буквы в Edit1 вашего собранного на Delphi калькулятора, хотя ежу понятно, что вводить нужно цифры… Beep или не Beep, но всё равно надо просветить неумеху сообщением. </P>

<P>Самый простой способ - procedure ShowMessage(const Msg: String) из модуля Dialogs.pas. Текст сообщения, как вы понимаете, заключен в одинарные кавычки (клавиша "Э") и может содержать не больше 255 символов.</P>

<P>Вот наш (со вводом в TEdit) пример:</P>

<P>
<PRE>
procedure TForm1.Edit1KeyPress(Sender: TObject; var Key: Char);
begin
if Key in ['А'..'я'] then begin 
Key:=#0;
Beep;

//НАШЕ СООБЩЕНИЕ:
ShowMessage('Переключитесь на английскую раскладку');

end;
end;
</PRE></P>

<P>Пользователь увидит предупреждение с тем же заголовком, что и у вашего проекта. Окошко будет содержать одну кнопку "ОК", которая отвечает только за закрытие сообщения; стало быть, на нее нельзя "повесить" какую-нибудь функцию. </P>

<P>Расширить наши возможности призвана function MessageDlg(const Msg: String; DlgType: TMsgDlgType; Buttons: TMsgDlgButtons; HelpCtx: integer): integer, которую мы разберем по косточкам:</P>

<P>
<UL>
<LI>Msg - 'Текст сообщения'</LI>
<LI>DlgType - Вид диалогового окна. Доступно:</LI>
<UL>
<LI>mtWarning</LI>
<LI>mtError</LI>
<LI>mtInformation</LI>
<LI>mtConfirmation</LI>
<LI>mtCustom</LI>
</UL>
<LI>Buttons - кнопки диалогового окна: mbYes, mbNo, MbCancel, mbRetry, mbAbort, mbOk, mbIgnore, mbHelp, mbAll, mbYesToAll, mbNoToAll - словом, все, какие ни есть и даже готовые комбинации: mbYesNoCancel, mbOKCancel, mbYesAllNoAllCancel, mbAbortRetryIgnore, bmAbortIgnore.
<BR>Если вы хотите воспользоваться одной из этих готовых закладок, пропишите, к примеру: mbYesNoCancel; хотите совместить несколько - введите параметры в квадратных скобках через запятую: [mbYes, mbYesToAll]; если одну - тоже: [mbIgnore]</LI>
</UL>HelpCtx оставьте равным нулю и больше о нём не вспоминайте.</P>

<P>Теперь создадим пример. В OnCreate или, еще лучше, в OnCloseQuery (закладка Events в Form1) пропишите:</P>

<P>
<PRE>
Beep; //привлекаем внимание пользователя
MessageDlg('Нажмите ОК, чтобы закрыть приложение', mtInformation, mbOKCancel, 0);
</PRE></P>

<P>Посмотрели? Ах да, что ОК нажимай, что Cancel - программа все равно закрывается. Чтобы система результировала щелчки на кнопки, воспользуемся обработчиком case…of.</P>

<P>
<PRE>
procedure TForm1.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
begin
case MessageDlg('Нажмите ОК, чтобы закрыть приложение',mtInformation,mbOkCancel,0) of
idOk: Application.Terminate;
idCancel: Abort;
end;
end;
</PRE></P>

<P>Согласно механизмам Delphi, функция MessageDlg возвращает значение своего результата - нажатой клавиши - integer (простое число), которое считывается обработчиком case…of. Не забудьте в синтаксисе этого обработчика употреблять id_название_кнопки вместо mb_название_кнопки.</P>

<P>Только вот клавиши диалогового окна английские. Но и это не беда. Перейдем к function MessageBox(Parent: HWnd; Txt, Caption: PChar; TextType: Word): Integer, где</P>

<P>
<UL>
<LI>Parent - "хозяин" (окно, владеющее сообщением) - указывайте Form1.handle или Application.handle;</LI>
<LI>Txt - 'текст сообщения';</LI>
<LI>Caption - 'его заголовок';</LI>
<LI>TextType - параметр, объединяющий DlgType и Buttons в предыдущей функции.</LI>
</UL>MessageBox не только использует не стандартные английские кнопки, а их русифицированные эквиваленты из ресурсов Windows, но - что еще более круто - генерирует при возникновении звуковой сигнал, соответствующий параметру TextType</P>

<P>Кстати, MessageBox находится в модуле Windows.pas и потому может использоваться для подачи сообщений в консольных приложениях. Напишем пример.</P>

<P>Откройте File>New>Other> и выберите Console Application. Delphi создаст заготовку. Оставьте в Uses один модуль Windows и ниже продекларируйте var-параметр h: hwnd. При компиляции может появиться предупреждение, что эта переменная не проинициализировалась, но (в Delphi 6, по крайней мере) исполняемый файл создается. А его размер вас приятно удивит:</P>

<P>
<PRE>
program Project1;

uses Windows;

var h: hwnd;

begin
MessageBox(h,'И консольные приложения могут быть диалоговыми!','Delphi для всех',1);
end.
</PRE></P>

<P>Разобрались? С сообщениями всё понятно. В приложении под Win32 (с формой) не вводите переменную h, а сразу в скобках пишите: Form1.handle. Но как заставить ЮЗЕРА отправить сообщение вашей программе, например, если нужно ввести серийный номер? С помощью функции InputBox! Сейчас мы создадим сообщение со строкой ввода:</P>

<P>
<PRE>
procedure TForm1.Button1Click(Sender: TObject);
begin
Form1.Caption:=InputBox('Сменить заголовок', 'Введите текст заголовка формы', 'Ваш_заголовок');
end;
</PRE></P>

<P>К сожалению, в этой функции невозможно использовать case…of - по крайней мере я не знаю как </P>

<P>…А еще я не сказал вам про функции ShowMessagePos, MessageDlgPos с дополнительными параметрами Left и Top, обозначающимися X и Y… Но вы не ламер - чай, сами разберетесь .</P>
</BODY>
</HTML>