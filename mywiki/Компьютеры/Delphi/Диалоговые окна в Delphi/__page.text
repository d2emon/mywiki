!! Диалоговые окна в Delphi: руководство для начинающих

С первых шагов в Inprise Delphi программист сталкивается с необходимостью так или иначе привлекать внимание пользователя к событиям внутри приложения или операционной системы - или, еще лучше, выводить диалоговые окна, например, при запросе на сохранение, как это реализовано в старом добром Блокноте. 

Добрый дядюшка Borland любезно снабдил нас такой функцией, как beep, заставляющей PC Speaker пищать, - это полезно, например, если юзер начнет тупо набирать буквы в Edit1 вашего собранного на Delphi калькулятора, хотя ежу понятно, что вводить нужно цифры… Beep или не Beep, но всё равно надо просветить неумеху сообщением. 

Самый простой способ - procedure ShowMessage(const Msg: String) из модуля Dialogs.pas. Текст сообщения, как вы понимаете, заключен в одинарные кавычки (клавиша "Э") и может содержать не больше 255 символов.

Вот наш (со вводом в TEdit) пример:

[@
procedure TForm1.Edit1KeyPress(Sender: TObject; var Key: Char);
begin
if Key in ['А'..'я'] then begin 
Key:=#0;
Beep;

//НАШЕ СООБЩЕНИЕ:
ShowMessage('Переключитесь на английскую раскладку');

end;
end;
@]

Пользователь увидит предупреждение с тем же заголовком, что и у вашего проекта. Окошко будет содержать одну кнопку "ОК", которая отвечает только за закрытие сообщения; стало быть, на нее нельзя "повесить" какую-нибудь функцию. 

Расширить наши возможности призвана function MessageDlg(const Msg: String; DlgType: TMsgDlgType; Buttons: TMsgDlgButtons; HelpCtx: integer): integer, которую мы разберем по косточкам:

* Msg - 'Текст сообщения'
* DlgType - Вид диалогового окна. Доступно: 
** mtWarning
** mtError
** mtInformation
** mtConfirmation
** mtCustom
* Buttons - кнопки диалогового окна: mbYes, mbNo, MbCancel, mbRetry, mbAbort, mbOk, mbIgnore, mbHelp, mbAll, mbYesToAll, mbNoToAll - словом, все, какие ни есть и даже готовые комбинации: mbYesNoCancel, mbOKCancel, mbYesAllNoAllCancel, mbAbortRetryIgnore, bmAbortIgnore.[[<<]]Если вы хотите воспользоваться одной из этих готовых закладок, пропишите, к примеру: mbYesNoCancel; хотите совместить несколько - введите параметры в квадратных скобках через запятую: [mbYes, mbYesToAll]; если одну - тоже: [mbIgnore]
HelpCtx оставьте равным нулю и больше о нём не вспоминайте.

Теперь создадим пример. В OnCreate или, еще лучше, в OnCloseQuery (закладка Events в Form1) пропишите:

[@
Beep; //привлекаем внимание пользователя
MessageDlg('Нажмите ОК, чтобы закрыть приложение', mtInformation, mbOKCancel, 0);
@]

Посмотрели? Ах да, что ОК нажимай, что Cancel - программа все равно закрывается. Чтобы система результировала щелчки на кнопки, воспользуемся обработчиком case…of.

[@
procedure TForm1.FormCloseQuery(Sender: TObject; var CanClose: Boolean);
begin
case MessageDlg('Нажмите ОК, чтобы закрыть приложение',mtInformation,mbOkCancel,0) of
idOk: Application.Terminate;
idCancel: Abort;
end;
end;
@]

Согласно механизмам Delphi, функция MessageDlg возвращает значение своего результата - нажатой клавиши - integer (простое число), которое считывается обработчиком case…of. Не забудьте в синтаксисе этого обработчика употреблять id_название_кнопки вместо mb_название_кнопки.

Только вот клавиши диалогового окна английские. Но и это не беда. Перейдем к function MessageBox(Parent: HWnd; Txt, Caption: PChar; TextType: Word): Integer, где

* Parent - "хозяин" (окно, владеющее сообщением) - указывайте Form1.handle или Application.handle;
* Txt - 'текст сообщения';
* Caption - 'его заголовок';
* TextType - параметр, объединяющий DlgType и Buttons в предыдущей функции.

MessageBox не только использует не стандартные английские кнопки, а их русифицированные эквиваленты из ресурсов Windows, но - что еще более круто - генерирует при возникновении звуковой сигнал, соответствующий параметру TextType

Кстати, MessageBox находится в модуле Windows.pas и потому может использоваться для подачи сообщений в консольных приложениях. Напишем пример.

Откройте File>New>Other> и выберите Console Application. Delphi создаст заготовку. Оставьте в Uses один модуль Windows и ниже продекларируйте var-параметр h: hwnd. При компиляции может появиться предупреждение, что эта переменная не проинициализировалась, но (в Delphi 6, по крайней мере) исполняемый файл создается. А его размер вас приятно удивит:

[@
program Project1;

uses Windows;

var h: hwnd;

begin
MessageBox(h,'И консольные приложения могут быть диалоговыми!','Delphi для всех',1);
end.
@]

Разобрались? С сообщениями всё понятно. В приложении под Win32 (с формой) не вводите переменную h, а сразу в скобках пишите: Form1.handle. Но как заставить ЮЗЕРА отправить сообщение вашей программе, например, если нужно ввести серийный номер? С помощью функции InputBox! Сейчас мы создадим сообщение со строкой ввода:

[@
procedure TForm1.Button1Click(Sender: TObject);
begin
Form1.Caption:=InputBox('Сменить заголовок', 'Введите текст заголовка формы', 'Ваш_заголовок');
end;
@]

К сожалению, в этой функции невозможно использовать case…of - по крайней мере я не знаю как 

…А еще я не сказал вам про функции ShowMessagePos, MessageDlgPos с дополнительными параметрами Left и Top, обозначающимися X и Y… Но вы не ламер - чай, сами разберетесь .