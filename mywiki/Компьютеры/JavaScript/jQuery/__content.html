<!DOCTYPE html>
<HTML>
<HEAD>
	<META HTTP-EQUIV='CONTENT-TYPE' CONTENT='TEXT/HTML; CHARSET=UTF-8'/>

	<STYLE type="text/css">
		body, div, p, table {
			font-size:10pt;
			font-family:Verdana;
		}

		img{border:none}
		
	</STYLE>
	
</HEAD>

<BODY>
<P>
<H1>jQuery – Javascript нового поколения</H1></P>

<P><I>Автор: Dmitrii 'Mamut' Dimandt </I>
<BR><I>Источник: RSDN Magazine #1-2007</I></P>

<P>
<H2>Веб приложения. И побольше, побольше!</H2></P>

<P>Тенденция последних лет в создании веб-приложений – использование функциональности, которая до этого была доступна только прикладным программам. Это и всевозможная анимация, и общение с сервером без перезагрузки страницы, и использование «не веб»-элементов (деревья, табы, сплиттеры и многое другое).</P>

<P>Над самим термином «клиентское веб-приложение» можно смеяться, о нем можно дискутировать, но факт остается фактом – уже появились решения, которые кроме как «веб-приложением» назвать нельзя (взять тот же Gmail, например). И теперь наша задача, как разработчиков, взять на вооружение все, что позволит создавать новые приложения, которые соответствуют новым, пока еще правда сырым, стандартам, объединяемым звучным названием «Веб 2.0».</P>

<P>Большая часть технологической стороны новых веб-приложений опирается на предсказуемость поведения современных браузеров. Все наиболее распространенные браузеры разве что не препарированы энтузиастами. Такие копания во внутренностях позволяют этим же энтузиастам создавать разнообразный инструментарий для работы над веб-приложениями в целом, так и над каждой веб-страницей в отдельности. Но так как в заголовок статьи вынесено слово «Javascript», то и говорить мы будем о нем.</P>

<P>Веб-приложения стремятся приблизиться к функциональности настольных приложений. Но так как ключевые веб-технологии (HTML и CSS) являются статическими, то вся необходимая функциональность реализуется с помощью Javascript.</P>

<P>Существуют десятки, если не сотни, библиотек, позволяющих реализовывать такие вещи, как красочные графические эффекты и анимацию, перетягивание и сортировку предметов, общение с сервером без перезагрузки страницы и многое, многое другое. Большинство таких библиотек отличает некоторая монструозность и, зачастую, сложность в использовании. Особенно в сравнении с библиотекой, о которой пойдет речь в этой статье.</P>

<P>
<H2>jQuery</H2></P>

<P>
<H3>С места в карьер</H3></P>

<P>Начну сразу с интересного, хоть и непрактичного примера. Нам необходимо раскрасить таблицу в таком стиле:</P>

<P><IMG SRC="__attach/jQueryzebra-table.PNG"/></P>

<P>Предполагается, что у нас есть CSS-файл, в котором определен класс «odd». Все, что нам нужно сделать, – это наделить нечетные строки в таблице эти классом. Для начала – решение на чистом Javascript:</P>

<P><code>
<BR><span class="KEYWORD">var</span> tables = document.getElementsByTagName(<span class="STRING">"table"</span>);
<BR><span class="KEYWORD">for</span> ( <span class="KEYWORD">var</span> t = 0; t &lt; tables.length; t++ ) {
<BR>  <span class="KEYWORD">var</span> rows = tables[t].getElementsByTagName(<span class="STRING">"tr"</span>);
<BR>  <span class="KEYWORD">for</span> ( <span class="KEYWORD">var</span> i = 1; i &lt; rows.length; i += 2 )
<BR>    <span class="KEYWORD">if</span> ( !/(^|s)odd(s|$)/.test( rows[i].className ) )
<BR>      rows[i].className += <span class="STRING">" odd"</span>;
<BR>}
<BR></code></P>

<P>Теперь – решение, использующее одну из самых популярных на сегодняшний день библиотек, Prototype:</P>

<P><code>
<BR>$$(<span class="STRING">"table"</span>).each(<span class="KEYWORD">function</span>(table){
<BR>  Selector.findChildElements(table, [<span class="STRING">"tr"</span>])
<BR>    .findAll(<span class="KEYWORD">function</span>(row,i){ <span class="KEYWORD">return</span> i % 2 == 1; })
<BR>    .invoke(<span class="STRING">"addClassName"</span>, <span class="STRING">"odd"</span>);
<BR>});
<BR></code></P>

<P>Ну а теперь – jQuery:</P>

<P><code>
<BR>$(<span class="STRING">"tr:nth-child(odd)"</span>).addClass(<span class="STRING">"odd"</span>);
<BR></code></P>

<P>Как видно из этого примера, библиотека jQuery позволяет находить простые и изящные решения для, казалось бы, сложных задач.</P>

<P>
<H3>Элементарно, Ватсон</H3></P>

<P>Ключом к пониманию работы jQuery является функция $(). Эта функция, так или иначе, вызывается всеми методами jQuery. Как будет показано дальше, со стороны эта функция выглядит действительно магической.</P>

<P>
<H4>Доллары, доллары, доллары</H4></P>

<P>Определение функции $ можно увидеть в листинге 1. Вне зависимости от параметров, переданных в функцию, знак доллара вернет список объектов, над которым уже определены все доступные jQuery-функции (а их немало). Это позволяет работать с любыми объектами – уже существующими на странице, созданными динамически или полученными через AJAX – так, как будто это одни и те же элементы, уже существующие на странице.</P>

<P><B>Листинг 1. Определение функции $():</B></P>

<P><code>
<BR>$(html)
<BR>$(elems)
<BR>$(fn)
<BR>$(expr, context)
<BR></code></P>

<P>Разберемся с каждым поподробнее.</P>

<P><B>$(html)</B></P>

<P>Позволяет создать html-элементы «на лету» из «чистого» HTML. Например, можно создать элемент div, содержащий параграф с текстом «Ба-бах!» и добавить его к элементу с id="body" таким образом:</P>

<P><code>
<BR><span class="KEYWORD">var</span> my_div = $(<span class="STRING">"&lt;div&gt;&lt;p&gt;Ба-бах!&lt;/p&gt;&lt;/div&gt;"</span>);
<BR>my_div.appendTo(<span class="STRING">"#body"</span>);
<BR></code></P>

<P>Или еще короче:</P>

<P><code>
<BR>$(<span class="STRING">"&lt;div&gt;&lt;p&gt;Ба-бах!&lt;/p&gt;&lt;/div&gt;"</span>).appendTo(<span class="STRING">"#body"</span>);
<BR></code></P>

<P>Элемент до отработки скрипта:</P>

<P><code>
<BR>&lt;div id=<span class="STRING">"body"</span>&gt;&lt;/div&gt;
<BR></code></P>

<P>Элемент после отработки скрипта:</P>

<P><code>
<BR>&lt;div id=<span class="STRING">"body"</span>&gt;&lt;div&gt;&lt;p&gt;Ба-бах!&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;
<BR></code></P>

<P><B>$(elems)</B></P>

<P>Позволяет «прицепить» всю функциональность jQuery к уже существующим элементам страницы (а именно, к элементам из объектной модели документа, из DOM). Примеры:</P>

<P><code>
<BR>$(document.body).css( <span class="STRING">"background-color"</span>, <span class="STRING">"black"</span> );
<BR>$( myForm.elements ).hide();
<BR></code></P>

<P><B>$(expr[, context])</B></P>

<P>Это самая магическая форма функции $, и наиболее часто используемая. Первый, обязательный, параметр – это выражение, которое позволит jQuery найти элемент на странице. Второй, необязательный, параметр указывает, где искать этот элемент (по умолчанию jQuery будет искать по всей странице).</P>

<P>Найдем все элементы p, находящиеся внутри всех элементов div на странице:</P>

<P><code>
<BR>$(<span class="STRING">"div &gt; p"</span>);
<BR></code></P>

<P>Наш документ:</P>

<P><code>
<BR>&lt;p&gt;one&lt;/p&gt; &lt;div&gt;&lt;p&gt;two&lt;/p&gt;&lt;/div&gt; &lt;p&gt;three&lt;/p&gt;
<BR></code></P>

<P>Результат:</P>

<P><code>
<BR>[ &lt;p&gt;two&lt;/p&gt; ]
<BR></code></P>

<P>Найдем все радиокнопки в первой форме на странице:</P>

<P><code>
<BR>$(<span class="STRING">"input:radio"</span>, document.forms[0]);
<BR></code></P>

<P>Найдем все элементы div в XML, что прислан с сервера с помощью технологии AJAX:</P>

<P><code>
<BR>$(<span class="STRING">"div"</span>, xml.responseXML);
<BR></code></P>

<P>«Но как же так?» - воскликнет читатель. Как это все работает?</P>

<P>Дело в том, что в jQuery реализован очень интересный механизм поиска элементов, использующий CSS и Xpath. То есть, для нахождения требуемого элемента вы можете воспользоваться как механизмом селекторов CSS, так и запросами по документу в стиле Xpath. Все еще непонятно?</P>

<P>CSS в версиях 1-3 предлагает разработчику богатые возможности оформления страниц (как минимум, теоретически). Например, чтобы пометить элементы div в параграфах с классом «highlight» красным цветом, разработчик может составить такую конструкцию:</P>

<P><code>
<BR>p.highlight &gt; div 
<BR>{
<BR>  color: #F00;
<BR>}
<BR></code></P>

<P>Вспомните пример с раскраской таблицы. Согласно CSS 3 раскрасить таблицу в зебру можно так:</P>

<P><code>
<BR>table tr:nth-child(odd)
<BR>{
<BR>  background-color: magenta;
<BR>}
<BR></code></P>

<P>Вспомним тогда еще раз, как мы раскрасили таблицу с помощью jQuery:</P>

<P><code>
<BR>$(<span class="STRING">"tr:nth-child(odd)"</span>).addClass(<span class="STRING">"odd"</span>);
<BR></code></P>

<P><I>Мы использовали селекторы CSS для нахождения нужных нам элементов и манипуляций над ними!</I></P>

<P>Практически все селекторы из CSS 1-3 можно использовать для нахождения элементов на странице. В конце статьи приведен краткий справочник по доступным селекторам, а пока рассмотрим примеры.</P>

<P>Найдем элемент с id="unique":</P>

<P><code>
<BR>$(<span class="STRING">"#unique"</span>);  
<BR><span class="COMMENT">// аналог из CSS:</span>
<BR><span class="COMMENT">// #unique {...}</span>
<BR></code></P>

<P>Найдем все элементы A, имеющие класс «external» (то есть все <a class="external">)</P>

<P><code>
<BR>$(<span class="STRING">"a.external"</span>);
<BR><span class="COMMENT">// аналог из CSS:</span>
<BR><span class="COMMENT">// a.external {...}</span>
<BR></code></P>

<P>Найдем все нечетные элементы div, находящиеся внутри элементов div с классом news-item, который находится внутри элемента div с id="outer"</P>

<P><code>
<BR>$(<span class="STRING">"#outer &gt; div.news-item &gt; p:nth-child(odd)"</span>);
<BR></code></P>

<P>Как видно, фантазия разработчика ограничена только возможностями CSS. Когда же возможностей CSS не хватает, на помощь приходит XPath.</P>

<P>Согласно определению из Википедии, XPath (XML Path Language) является языком для обращения к частям XML-документа. Вспомним, что HTML, или вернее, XHTML, является подмножеством XML, и станет понятно, что практически не существует причин, по которым с помощью XPath нельзя было бы обращаться к частям HTML-документа. Вернее, их нет для jQuery, так как эта библиотека поддерживает довольно большое подмножество XPath (более полная информация приведена во врезке) и лихо объединяет его с некоторыми селекторами CSS для создания невероятно гибкого механизма поиска элементов на странице.</P>

<P>Найдем все элементы P, которые содержат ссылку</P>

<P><code>
<BR>$(<span class="STRING">"p[a]"</span>);
<BR></code></P>

<P>Найдем все элементы A, которые содержат атрибут rel, равный "nofollow":</P>

<P><code>
<BR>$(<span class="STRING">"//a[@rel='nofollow']"</span>);
<BR></code></P>

<P>Найдем все видимые элементы LI внутри элемента UL</P>

<P><code>
<BR>$(<span class="STRING">"ul/li:visible"</span>);   <span class="COMMENT">// XPath + селектор</span>
<BR><span class="COMMENT">// или</span>
<BR>$(<span class="STRING">"ul &gt; li:visible"</span>); <span class="COMMENT">// CSS + селектор</span>
<BR></code></P>

<P>Как видите, если вы знаете, какой элемент необходимо выбрать, jQuery позволит это сделать. Например, в одном из текущих проектов мы используем вот такой код:</P>

<P><code>
<BR><span class="COMMENT">// Находим необходимую нам радиокнопку и эмулируем нажатие на нее</span>
<BR>$(<span class="STRING">"input[@value='1']:radio"</span>).click();
<BR>
<BR><span class="COMMENT">// Находим необходимую нам опцию в списке и выбираем ее 
<BR>// (устанавливаем значение атрибута selected равным "selected"):</span>
<BR>$(<span class="STRING">"option[@value='1']"</span>).attr(<span class="STRING">"selected"</span>, <span class="STRING">"selected"</span>);
<BR></code></P>

<P>
<H3>На старт, внимание, марш!</H3></P>

<P>Большинство (если не все) библиотек JavaScript часто использует событие window.onload. Это событие вызывается после того, как документ полностью загрузился в окно браузера. Это значит, что вызываемый в обработчике этого события код не сработает, пока не загрузятся все изображения, флэш-баннеры и видеоролики на странице.</P>

<P>jQuery предлагает решение этой проблемы. У разработчика есть возможность выполнить свой код в тот момент, когда доступна объектная модель документа, то есть когда браузер уже получил исходный код страницы полностью, но, возможно, еще не подгрузил различное мультимедийное содержимое (рисунки, видео, флэш).</P>

<P>Возможность выполнить такой код предлагается методом .ready():</P>

<P><code>
<BR>$(document).ready(
<BR>  <span class="KEYWORD">function</span>() { <span class="COMMENT">/* ... */</span>}
<BR>);
<BR></code></P>

<P>или его сокращенным вариантом, $(fn):</P>

<P><code>
<BR>$(
<BR>  <span class="KEYWORD">function</span>(){<span class="COMMENT">/* ... */</span>}
<BR>);
<BR></code></P>

<P>В качестве аргумента в .ready() передается функция, которая будет выполнять все необходимые действия.</P>

<P>Пример.</P>

<P><code>
<BR>$(document).ready(
<BR>  <span class="KEYWORD">function</span>()
<BR><span class="KEYWORD">  </span>{
<BR>    <span class="COMMENT">// добавим ко всем ссылкам на странице некий текст</span>
<BR>    $(<span class="STRING">"a"</span>).append(<span class="STRING">"&lt;span&gt;(opens in new window)&lt;/span&gt;"</span>);
<BR>  }
<BR>);
<BR></code></P>

<P>Пример.</P>

<P><code>
<BR>$(document).ready(init);
<BR><span class="KEYWORD">function</span> init()
<BR>{
<BR>  <span class="COMMENT">// находим все элементы Р с классом highlight и задаем им другой фон</span>
<BR>  $(<span class="STRING">"p.highlight"</span>).css(<span class="STRING">"background-color"</span>, <span class="STRING">"#000"</span>);
<BR>
<BR>
<BR>  <span class="COMMENT">// естественно, можно выполнять любые действия</span>
<BR>  alert('Функция init()');
<BR>
<BR>
<BR>  <span class="COMMENT">// вызывать другие функции</span>
<BR>  anotherFunc();
<BR>
<BR>
<BR>  <span class="COMMENT">// манипулировать объектами в документе</span>
<BR>  document.getElementById(<span class="STRING">"some_id"</span>);
<BR>}
<BR></code></P>

<P>Пример.</P>

<P><code>
<BR><span class="COMMENT">// Используем кратую форму записи</span>
<BR>$(
<BR>  <span class="KEYWORD">function</span>()
<BR><span class="KEYWORD">  </span>{
<BR>    alert('документ готов!');
<BR>  }
<BR>)
<BR></code></P>

<P>СОВЕТ
<BR>Я рекомендую использовать длинную форму записи, то есть $(document).ready(),чтобы избежать неявных ошибок в коде.</P>

<P>
<H3>Как много нам открытий чудных...</H3></P>

<P>jQuery предлагает разработчику большое количество методов для манипуляции элементами документа и их свойствами. Кратко рассмотрим некоторые из этих методов, а также некоторые особенности работы с ними.</P>

<P>
<H4>Ловкость рук и никакого мошенничества</H4></P>

<P><TABLE ><TR><TD>append(content)/prepend(content)</TD><TD>Добавить переданный элемент или выражение в конец/в начало выбранного элемента.</TD></TR><TR><TD>appendTo(expr)/prependTo(expr)</TD><TD>Добавить выбранный элемент в конец/в начало переданного элемента.</TD></TR><TR><TD>attr(name)</TD><TD>Получить значение атрибута.</TD></TR><TR><TD>attr(params)</TD><TD>Установить значение атрибутов. Атрибуты передаются в виде {ключ1:значение1[, ключ2:значение2[, …]]}</TD></TR><TR><TD>attr(name, value)</TD><TD>Установить значение одного атрибута.</TD></TR><TR><TD>css(name)/css(params)/css(name, value)</TD><TD>Получить/установить значение отдельных параметров CSS. Аналогично функции attr().</TD></TR><TR><TD>text()/text(val)</TD><TD>Получить/задать текст элемента. В случае ввода текста специальные символы HTML заменяются символьными примитивами (entities, например, знак "&gt;" будет заменен &amp;gt;).</TD></TR><TR><TD>empty()</TD><TD>Удалить все подэлементы текущего элемента.</TD></TR></TABLE>
<BR>Примеры.</P>

<P>В следующих примерах мы будем работать со следующим HTML-кодом:</P>

<P><code>
<BR>&lt;div id=<span class="STRING">"my-div"</span>&gt;
<BR>  &lt;a href=<span class="STRING">"<A HREF="http://google.com/">http://google.com/</A>"</span> id=<span class="STRING">"my-link"</span>&gt;Ссылка&lt;/a&gt;
<BR>&lt;/div&gt;
<BR></code></P>

<P>Пример.</P>

<P><code>
<BR>$(<span class="STRING">"#my-div"</span>).html();    <span class="COMMENT">// Вернет &lt;a href="#" id="my-link"&gt;Ссылка&lt;/a&gt;</span>
<BR></code></P>

<P>Пример.</P>

<P><code>
<BR>$(<span class="STRING">"#my-link"</span>).attr(<span class="STRING">"href"</span>);  <span class="COMMENT">// Вернет <A HREF="http://google.com/">http://google.com/</A></span>
<BR></code></P>

<P>Пример.</P>

<P><code>
<BR>$(<span class="STRING">"#my-div"</span>).append(<span class="STRING">"&lt;strong&gt;Полужирный текст&lt;/strong&gt;"</span>);
<BR><span class="COMMENT">// или</span>
<BR>$(<span class="STRING">"&lt;strong&gt;Полужирный текст&lt;/strong&gt;"</span>).appendTo($(<span class="STRING">"#my-div"</span>));
<BR></code></P>

<P>HTML станет таким:</P>

<P><code>
<BR>&lt;div id=<span class="STRING">"my-div"</span>&gt;
<BR>  &lt;a href=<span class="STRING">"<A HREF="http://google.com/">http://google.com/</A>"</span> id=<span class="STRING">"my-link"</span>&gt;Ссылка&lt;/a&gt;
<BR>  &lt;strong&gt;Полужирный текст&lt;/strong&gt;
<BR>&lt;/div&gt;
<BR></code></P>

<P>Пример.</P>

<P><code>
<BR>$(<span class="STRING">"#my-div"</span>).empty();
<BR></code></P>

<P>HTML станет таким:</P>

<P><code>
<BR>&lt;div id=<span class="STRING">"#my-div"</span>&gt;&lt;/div&gt;
<BR></code></P>

<P>Пример.</P>

<P><code>
<BR>$(<span class="STRING">"#my-div"</span>).text(<span class="STRING">"&lt;a&gt;Якорь&lt;/a&gt;"</span>);
<BR></code></P>

<P>HTML станет таким:</P>

<P><code>
<BR>&lt;div id=<span class="STRING">"#my-div"</span>&gt;&amp;lt;a&amp;gt;Якорь&amp;lt;/a&amp;gt;&lt;/div&gt;
<BR></code></P>

<P>Пример.</P>

<P><code>
<BR>$(<span class="STRING">"#my-div"</span>).css(
<BR>  {
<BR>    backgroundColor: <span class="STRING">"#F00"</span>,
<BR>    color: <span class="STRING">"#00F"</span>
<BR>  }
<BR>);
<BR></code></P>

<P>HTML станет таким:</P>

<P><code>
<BR>&lt;div id=<span class="STRING">"my-div"</span> style=<span class="STRING">"background-color: #F00; color: #00F"</span>&gt;
<BR>  &amp;lt;a&amp;gt;Якорь&amp;lt;/a&amp;gt;
<BR>&lt;/div&gt;
<BR></code></P>

<P>В последнем примере обратите внимание, что для сложносоставных свойств CSS вроде background-color, font-weight и прочих используются их эквиваленты из Javascript (backgroundColor, fontWeight и т.п.).</P>

<P>
<H4>Связанные одной цепью</H4></P>

<P>Главная особенность большинства методов jQuery – это возможность связывать их в цепочки. Методы, манипулирующие элементами документа, обычно возвращают эти объекты для дальнейшего использования, что позволяет писать примерно следующее:</P>

<P>Пример.</P>

<P><code>
<BR><span class="COMMENT">// Заполняем скрытый элемент &lt;div id="divEdit"&gt;&lt;/div&gt; текстом и показываем его</span>
<BR>$(<span class="STRING">"#divEdit"</span>).html(response).show();
<BR></code></P>

<P>Пример.</P>

<P><code>
<BR>// найти &lt;select id="my_select"&gt;...&lt;/select&gt;</span>
<BR><span class="KEYWORD">var</span> sel = $(<span class="STRING">"#my_select"</span>);
<BR>
<BR>
<BR><span class="COMMENT">// добавляем к нему &lt;option value="1"&gt;Пример опции&lt;/option&gt;</span>
<BR>$(<span class="STRING">"&lt;option&gt;&lt;/option&gt;"</span>)  <span class="COMMENT">// создаем требуемый элемент</span>
<BR>  .attr(<span class="STRING">"value"</span>, 1)     <span class="COMMENT">// устанавливаем значение одного из его атрибутов</span>
<BR>  .html(<span class="STRING">"Пример опции"</span>) <span class="COMMENT">// записываем в него текст</span>
<BR>  .appendTo(sel);       <span class="COMMENT">// прикрепляем к уже существующему элементу</span>
<BR></code></P>

<P>Таким образом, можно легко описать все действия, происходящие с выбранным элементом, не затрудняясь введением большого количества временных переменных.</P>

<P>
<H4>Дважды в одну и ту же реку</H4></P>

<P>Некоторые действия в jQuery позволяют вернуться на предыдущий уровень в иерархии тегов. Например:</P>

<P>HTML</P>

<P><code>
<BR>&lt;p&gt;&lt;span&gt;Hello&lt;/span&gt;, how are you?&lt;/p&gt;
<BR></code></P>

<P>Javascript</P>

<P><code>
<BR>$(<span class="STRING">"p"</span>).find(<span class="STRING">"span"</span>);
<BR></code></P>

<P>Результат</P>

<P><code>
<BR>&lt;span&gt;Hello&lt;/span&gt;
<BR></code></P>

<P>Но что произошло вначале? Сначала был найден элемент P и только потом внутри него был найден элемент SPAN. Что же делать, если мы хотим продолжить работу с коллекцией элементов P? Для этого jQuery предлагает возможность вернуться к предыдущему уровню с помощью метода end(). Например:</P>

<P><code>
<BR>$(<span class="STRING">"p"</span>).find(<span class="STRING">"span"</span>).html(<span class="STRING">"Ahoy"</span>).end().append(<span class="STRING">"&lt;p&gt;I'm fine&lt;p&gt;"</span>);
<BR></code></P>

<P>Что здесь происходит? Пройдемся по всем этапам:</P>

<P><TABLE ><TR><TD>Код</TD><TD>Текущая коллекция элементов</TD></TR><TR><TD>$("p")</TD><TD>[&lt;p&gt;..&lt;/p&gt;]</TD></TR><TR><TD>.find("span")</TD><TD>[&lt;span&gt;..&lt;/span&gt;]</TD></TR><TR><TD>.html("Ahoy")</TD><TD>[&lt;span&gt;..&lt;/span&gt;]</TD></TR><TR><TD>.end()</TD><TD>[&lt;p&gt;..&lt;/p&gt;]</TD></TR><TR><TD>.append(...);</TD><TD>[&lt;p&gt;..&lt;/p&gt;]</TD></TR></TABLE>
<BR>В результате мы получим вот такой HTML:</P>

<P><code>
<BR>&lt;p&gt;&lt;span&gt;Ahoy&lt;/span&gt;, how are you?&lt;p&gt;I'm fine&lt;/p&gt;&lt;/p&gt;
<BR></code></P>

<P>Пример.</P>

<P>
<UL>
<LI>Найдем элемент &lt;body&gt;.</LI>
<LI>В нем найдем все элементы div и зададим им зеленый фон.</LI>
<LI>Вернемся к элементу &lt;body&gt;.</LI>
<LI>В нем найдем все элементы span и зададим им красную границу.</LI>
<LI>Вернемся к элементу &lt;body&gt;.</LI>
<LI>Зальем элемент &lt;body&gt; черным фоном.</LI>
</UL><code>
<BR>$(<span class="STRING">"body"</span>)                // 1
<BR>    .find(<span class="STRING">"div"</span>).css(<span class="STRING">"background-color"</span>, <span class="STRING">"green"</span>)    // 2
<BR>    .end()                // 3
<BR>    .find(<span class="STRING">"span"</span>).css(<span class="STRING">"border"</span>, <span class="STRING">"1px solid #F00"</span>)    // 4
<BR>    .end()                // 5
<BR>    .css(<span class="STRING">"background-color"</span>, <span class="STRING">"#000"</span>);
<BR></code></P>

<P>Предыдущий код эквивалентен следующему:</P>

<P><code>
<BR><span class="KEYWORD">var</span> body = $(<span class="STRING">"body"</span>);
<BR>$(<span class="STRING">"div"</span>, body).css(<span class="STRING">"background-color"</span>, <span class="STRING">"green"</span>);
<BR>$(<span class="STRING">"span"</span>, body).css(<span class="STRING">"border"</span>, <span class="STRING">"1px solid #F00"</span>);
<BR>body.css(<span class="STRING">"background-color"</span>, <span class="STRING">"#000"</span>);
<BR></code></P>

<P>ПРИМЕЧАНИЕ
<BR>Метод end() может как упростить, так и усложнить код, поэтому его использование остается на совести разработчика.</P>

<P>
<H3>Круговая порука</H3></P>

<P>Функция $() возвращает коллекцию элементов. Так, $("p") вернет массив всех элементов &lt;p&gt;, какие только могут присутствовать на странице (или пустой массив, если таких элементов не существует). Одним из условий работы большинства функций jQuery является непременная обработка всех элементов в возвращаемой коллекции. Например:</P>

<P>Цвет всех ссылок на странице станет зеленым:</P>

<P><code>
<BR>$("a").css("color", "green"); 
<BR></code></P>

<P>Ко всем элементам div с классом test будет добавлен новый элемент:</P>

<P><code>
<BR>$("div.test").append("&lt;span&gt;Тестовый элемент&lt;/span&gt;");
<BR></code></P>

<P>Но иногда необходимо обратиться к индивидуальным элементам возвращаемой коллекции.</P>

<P>
<H4>Индексы и get([index])</H4></P>

<P>Возвращаемая функцией $() коллекция является «псевдо»-массивом DOM-элементов. Поэтому можно обратиться к индивидуальным элементам по их индексу:</P>

<P><code>
<BR>$(<span class="STRING">"p"</span>)[0].className = <span class="STRING">"test"</span>;
<BR></code></P>

<P>Иногда, правда, необходимо обратиться непосредственно к массиву DOM-объектов, скрытых внутри «псевдо»-массива, которым является объект jQuery. Для этого используется функция get():</P>

<P><code>
<BR>$(<span class="STRING">"p"</span>); <span class="COMMENT">// Получили объект jQuery</span>
<BR>$(<span class="STRING">"p"</span>).get(); <span class="COMMENT">// Получили соответствующую коллекцию DOM-элементов</span>
<BR></code></P>

<P>Более того, метод get позволяет обращаться непосредственно к индивидуальным элементам коллекции:</P>

<P><code>
<BR>$(<span class="STRING">"a"</span>).get(0); <span class="COMMENT">// Получили первую из всех ссылок на странице</span>
<BR></code></P>

<P>Пример использования на практике:</P>

<P>HTML</P>

<P><code>
<BR>&lt;<span class="KEYWORD">select</span> id=<span class="STRING">"my-select"</span>&gt;
<BR>  &lt;option&gt;Option 1&lt;/option&gt;
<BR>  &lt;option&gt;Option 2&lt;/option&gt;
<BR>&lt;/<span class="KEYWORD">select</span>&gt;
<BR></code></P>

<P>Javascript</P>

<P><code>
<BR>$(<span class="STRING">"#my-select"</span>).get(0).selectedIndex = $(<span class="STRING">"#my-select"</span>).get(0).options.length – 1;
<BR></code></P>

<P>Как видите, здесь мы напрямую манипулируем свойствами объекта (выпадающего списка).</P>

<P>
<H4>each(fn)</H4></P>

<P>Иногда нужно пробежаться по всем элементам коллекции и выполнить над ними какие-то действия. Для этого нам понадобится функция each. Эта функция принимает в качестве аргумента другую функцию. each() работает в контексте найденных элементов и поэтому каждый раз, когда выполняется переданная ей функция, в этой функции доступна переменная this, указывающая на соответствующий DOM-элемент.</P>

<P>Пример.</P>

<P><code>
<BR>$(<span class="STRING">"p"</span>).each(
<BR>  <span class="KEYWORD">function</span>()
<BR>  {
<BR><span class="COMMENT">    // внутри функции this указывает на текущий DOM-элемент
<BR></span>    alert(<span class="KEYWORD">this</span>.innerHTML);
<BR>  }
<BR>);
<BR></code></P>

<P>В этом примере мы находим все элементы p на странице и для каждого из этих элементов вызываем функцию, которая показывает его содержимое.</P>

<P>Вспомните, что функция $ принимает в качестве параметра любые DOM-элементы. Поэтому alert можно было записать и так: alert($(this).html()). Такой способ, правда, заставляет jQuery производить лишние вычисления, чтобы найти соответствующий элемент, но и он имеет право на существование.</P>

<P>Функция, передаваемая в метод each(), может принимать на вход один аргумент, который является индексом текущего элемента в коллекции. Для иллюстрации перепишем самый первый пример в статье с помощью each(). Нам необходимо раскрасить все нечетные строки в таблице в другой цвет. Если у нас есть некая таблица с id="zebra" и CSS-класс «odd» для нечетных строк, то можно написать так:</P>

<P><code>
<BR>$(<span class="STRING">"#zebra tr"</span>).each(colorize); <span class="COMMENT">// передаем в each функцию colorize</span>
<BR>
<BR>
<BR><span class="KEYWORD">function</span> colorize(index)
<BR>{
<BR>  <span class="KEYWORD">if</span>(index % 2 == 1)       <span class="COMMENT">// index является индексом текущего элемента в коллекции</span>
<BR>    $(<span class="KEYWORD">this</span>).addClass(<span class="STRING">"odd"</span>);
<BR>}
<BR></code></P>

<P>
<H3>Кто сказал Flash?</H3></P>

<P>Грамотная манипуляция свойствами элементов на странице позволила создателям Javascript-библиотек создавать визуальные эффекты, которые раньше были возможны только при использовании технологии Flash. Это и плавное появление, и скрытие объектов, плавное изменение различных свойств этих объектов (фонового цвета, размеров), реализация всевозможных элементов интерфейса вроде сплиттеров, деревьев, перетягиваемых объектов и сортируемых списков.</P>

<P>В базовой поставке jQuery предлагает лишь ограниченный набор таких эффектов. Остальные эффекты реализуются при помощи модулей расширения (о которых речь пойдет ниже).</P>

<P>
<H4>Animate</H4></P>

<P>Ключевой функцией, на которой базируются все остальные, является функция animate:</P>

<P><code>
<BR>animate(params, speed, easing, callback); 
<BR></code></P>

<P>Здесь:</P>

<P>
<UL>
<LI>params – свойства, которые участвуют в анимации в виде пар {ключ: значение}. Например: {height: "show"} или {opacity: 50, width: 100, height: 200}.</LI>
<LI>speed – скорость в миллисекундах.</LI>
<LI>easing – замедлениие анимации (замедляется ли к концу, "easein", или, наоборот, ускоряется, "easeout". Дополнительные типы доступны в модулях расширения).</LI>
<LI>callback – функция, которая будет вызвана после завершения анимации.</LI>
</UL>Пример.</P>

<P>Пусть у нас есть элемент div с каким-нибудь текстом. Мы хотим скрыть этот текст, заменить новым, и показать обновленный текст.</P>

<P><code>
<BR>$(<span class="STRING">"#mydiv"</span>)
<BR>  .animate({height: <span class="STRING">"hide"</span>}, 300)
<BR>  .text(<span class="STRING">"Новый текст"</span>)
<BR>  .animate({height: <span class="STRING">"show"</span>}, 300);
<BR></code></P>

<P>ПРИМЕЧАНИЕ
<BR>Метод animate манипулирует только теми атрибутами, для которых можно выставить числовое значение (такие как height, weight, opacity, top и т.п.).</P>

<P>
<H4>Эффекты</H4></P>

<P>Метод animate является основой большинства, если не всех, эффектов jQuery и плагинов. Например, jQuery предлагает следующие методы для показа и скрытия элементов:</P>

<P>
<UL>
<LI>show([speed[, callback]]) – показать элемент;</LI>
<LI>hide([speed[, callback]]) – скрыть элемент;</LI>
<LI>fadeIn(speed[, callback]) – показать элемент путем изменения его прозрачности;</LI>
<LI>fadeOut(speed[, callback]) – скрыть элемент путем изменения его прозрачности;</LI>
<LI>slideDown(speed, callback) – показать элемент, спустив его сверху;</LI>
<LI>slideUp(speed, callback) – показать элемент, подняв его снизу;</LI>
</UL>где</P>

<P>speed – скорость в миллисекундах или одно из "slow" (600 миллисекунд) или "fast" (200 миллисекунд);</P>

<P>callback – функция, которая будет вызвана после выполнения анимации.</P>

<P>Рассмотрим, например, реализацию функции show:</P>

<P><code>
<BR>show: <span class="KEYWORD">function</span>(speed,callback){
<BR>  <span class="COMMENT">// находим в переданной нам коллекции скрытые элементы (см. врезку)</span>
<BR>  <span class="KEYWORD">var</span> hidden = <span class="KEYWORD">this</span>.filter(<span class="STRING">":hidden"</span>);
<BR>  <span class="COMMENT">// если нам передана скорость, то вызываем метод animate</span>
<BR>  if(speed)
<BR>  {
<BR>    hidden.animate(
<BR>      {
<BR>        height: <span class="STRING">"show"</span>, 
<BR>        width: <span class="STRING">"show"</span>, 
<BR>        opacity: <span class="STRING">"show"</span>
<BR>      }, 
<BR>      speed, 
<BR>      callback
<BR>    )
<BR>  }
<BR>  else
<BR>  {
<BR>    <span class="COMMENT">// иначе просто проходим по коллекции элементов и показываем их,</span>
<BR>    <span class="COMMENT">// меняя стиль display с none на block</span>
<BR>    hidden.each(
<BR>      <span class="KEYWORD">function</span>()
<BR><span class="KEYWORD">      </span>{
<BR>        <span class="KEYWORD">this</span>.style.display = <span class="KEYWORD">this</span>.oldblock ? <span class="KEYWORD">this</span>.oldblock : <span class="STRING">""</span>;
<BR>        <span class="KEYWORD">if</span> ( jQuery.css(<span class="KEYWORD">this</span>,<span class="STRING">"display"</span>) == <span class="STRING">"none"</span> )
<BR>          <span class="KEYWORD">this</span>.style.display = <span class="STRING">"block"</span>;
<BR>      }
<BR>    );
<BR>  }
<BR>  <span class="KEYWORD">return</span> <span class="KEYWORD">this</span>;
<BR>}
<BR></code></P>

<P>Скрытая мощь функции animate позволяет создавать поистине удивительные эффекты, многие из которых уже реализованы, например, в модуле расширения Interface (<A HREF="http://interface.eyecon.ro/)">http://interface.eyecon.ro/)</A>.</P>

<P>Необходимо также заметить, что все эффекты библиотеки jQuery применяются к элементам не сразу, а по очереди. То есть, предположим, что мы написали такой код:</P>

<P><code>
<BR><span class="KEYWORD">for</span>(i = 0; i &lt; 10; i++)
<BR>{
<BR>  $(<span class="STRING">"#my-div"</span>).animate({height: <span class="STRING">"show"</span>}, 300);
<BR>  $(<span class="STRING">"#my-div"</span>).animate({height: <span class="STRING">"hide"</span>}, 300);
<BR>}
<BR></code></P>

<P>В результате мы получим не беспорядочное моргание, пока двадцать эффектов борются за право показать/скрыть элемент «my-div», а плавный показ, потом сокрытие, потом снова показ – и так 20 раз. Обратите внимание, что очередь эффектов составляется поэлементно. То есть эффекты, примененные к разным элементам одновременно, будут выполняться одновременно.</P>

<P>
<H3>AJAX – как много в этом звуке!</H3></P>

<P>Web 2.0 неожиданно возродил технологию под названием XMLHttpRequest, появившуюся еще в 2000 году. Эта технология позволяет обращаться к серверу без перезагрузки текущей страницы. На данный момент можно считать, что все современные браузеры реализуют эту технологию в объеме, достаточном для безболезненного ее использования. В новой реинкарнации триумвират XMLHttpRequest, JavaScript и DOM называется AJAX.</P>

<P>Пуристы Web-технологий различают следующие подвиды этой технологии:</P>

<P>
<UL>
<LI>AJAX – Asynchronous JavaScript and XML, асинхронный Javascript и XML. В ответ на запрос с клиента сервер отвечает правильно сфоримированным XML-документом.</LI>
<LI>AJAH – Asynchronous JavaScript and HTML, асинхронный Javascript и HTML. В ответ на запрос с клиента сервер отвечает уже сгенерированным HTML-документом или его частью.</LI>
<LI>AHAH – Asynchronous HTML and HTTP, асинхронный HTML и HTTP. То же самое, что и AJAH.</LI>
<LI>AJAJ – JavaScript and JSON, асинхронный Javascript и JSON. В ответ на запрос с клиента сервер отвечает правильной записью объекта Javascript в формате JSON (<A HREF="http://json.org">http://json.org</A>).</LI>
</UL>jQuery предлагает реализацию всех трех подвидов технологии AJAX и еще один, AJAJs – все те же и Javascript. Теперь обо всем этом подробнее.</P>

<P>Базовыми функциями для работы с AJAX являются post() и get() (есть еще более низкоуровневая, ajax(), но мы ее не будем рассматривать):</P>

<P><code>
<BR>$.post(url[, params[, callback]])
<BR>$.get(url[, params[, callback]])
<BR></code></P>

<P>Здесь:</P>

<P>
<UL>
<LI>url – адрес страницы, на которую будет отправлен запрос;</LI>
<LI>params – параметры, передаваемые в запросе в виде пар «ключ : значение»;</LI>
<LI>callback – функция, которая будет вызвана в случае успешного завершения вызова.</LI>
</UL>Пример:</P>

<P><code>
<BR>$.post(
<BR>  '/ajaxtest.php',
<BR>  {
<BR>    type: <span class="STRING">"test-request"</span>,
<BR>    param1: <span class="STRING">"param1"</span>,
<BR>    param2: 2
<BR>  },
<BR>  onAjaxSuccess
<BR>);
<BR><span class="KEYWORD">function</span> onAjaxSuccess(data)
<BR>{
<BR>  <span class="COMMENT">// Здесь мы получаем данные, отправленные сервером</span>
<BR>  alert(data);
<BR>}
<BR></code></P>

<P>А что же на сервере? Вызов страницы при помощи технологии AJAX ничем не отличается от простого вызова страницы, например, путем открытия ее в браузере. То есть передаваемые параметры будут доступны на этой странице так же, как если бы они были переданы стандартными методами get или post. На сервере у нас может существовать, например, вот такой ajaxtest.php:</P>

<P><code>
<BR>&lt;?php
<BR><span class="COMMENT">// Если страница вызвана с помощью .post(), переданные значения будут,
<BR>// как всегда, доступны в глобальной переменной $_POST
<BR>// Если страница вызвана с помощью .get, переданные значения будут,
<BR>// как всегда, доступны в глобальной переменной $_GET
<BR></span>
<BR><span class="KEYWORD">echo</span> <span class="STRING">'text'</span>;
<BR>?&gt;
<BR></code></P>

<P>После того как ajaxtest.php отработает, в функцию onAjaxSuccess на клиенте будет передан текст «text». Обратите внимание на HTTP_X_REQUESTED_WITH. Этот HTTP-заголовок устанавливается jQuery во время запросов с помощью AJAX. Это помогает узнать, тип поступившего запроса и соответственно обрабатывать данные. Во всем остальном запрос через Аякс ничем не отличается от обычного запроса страницы у сервера.</P>

<P>ПРИМЕЧАНИЕ
<BR>В различных библиотеках, особенно использующих шаблон MVC, часто необходимо знать, как была вызвана страница – открыли ее в браузере или запросили через AJAX? При запросе с помощью технологии AJAX устанавливается HTTP-заголовок HTTP_X_REQUESTED_WITH со значением “XmlHTTPRequest”. Таким образом, в РНР, например, можно узнать, вызвана ли страница с помощью AJAX так:</P>

<P><code>
<BR><span class="KEYWORD">if</span>($_SERVER['HTTP_X_REQUESTED_WITH'] == 'XMLHttpRequest')
<BR>{
<BR>  <span class="COMMENT">// выполняем соответствующий код</span>
<BR>}
<BR></code></P>

<P>Теперь рассмотрим, как работать с четырьмя подвидами AJAX.</P>

<P>
<H4>AJAX</H4></P>

<P>Если сервер на запрос возвращает заголовок Content-Type: text/xml и правильно сформированный XML-документ, то в функцию onAjaxSuccess будет передан уже готовый к употреблению DOM этого документа, с которым можно будет работать, используя методы jQuery. Пример:</P>

<P>ajaxtest2.php:
<BR><code>
<BR>&lt;?php
<BR>  <span class="KEYWORD">header</span>(<span class="STRING">"Content-Type: text/xml; charset=utf-8"</span>);
<BR>?&gt;
<BR>&lt;list&gt;
<BR>  &lt;item id=<span class="STRING">"1"</span>&gt;
<BR>    Item 1 
<BR>  &lt;/item&gt;
<BR>  &lt;item id=<span class="STRING">"2"</span>&gt;
<BR>    Item 2 
<BR>  &lt;/item&gt;
<BR>&lt;/list&gt;</P>

<P>Наш JavaScript:</P>

<P><code>
<BR><span class="COMMENT">// Функцию post опускаем, написать ее не составляет труда</span>
<BR><span class="KEYWORD">function</span> onAjaxSuccess(xml)
<BR>{
<BR>  <span class="COMMENT">// Получаем коллекцию всех элементов item из пришедшего xml</span>
<BR>  items = $(<span class="STRING">"item"</span>, xml);
<BR>
<BR>
<BR>  <span class="COMMENT">// Находим item с id="1"</span>
<BR>  item = $(<span class="STRING">"#1"</span>, xml);
<BR>
<BR>
<BR>  <span class="COMMENT">// или при помощи XPath</span>
<BR>  item2 = $(<span class="STRING">"item[@id='2']"</span>, xml);
<BR>
<BR>
<BR>  <span class="COMMENT">// Извлекаем текст из элемента</span>
<BR>  alert(item2.html());  
<BR>}
<BR></code></P>

<P>Как видите, работа с полученным с сервера ответов в виде XML ничем не отличается от работы с уже загруженным в браузер документом.</P>

<P>
<H4>AHAH</H4></P>

<P>Как уже было видно в первом примере с методом post(), если значение заголовка Content-Type – не «text/xml», ответ с сервера передается как есть, в текстовом виде. Поскольку обычно такой ответ сразу показывается на странице без дополнительной обработки, то нет смысла заводить отдельные функции вроде onAjaxSuccess. Для получения и отображения полученного с сервера HTML jQuery предоставляет метод load:</P>

<P><code>
<BR>load(url[, params[, callback]]);
<BR></code></P>

<P>Этот метод прикрепляется к любому элементу на странице, в котором планируется показать ответ с сервера. После выполнения запроса ответ с сервера автоматически запишется в соответствующий элемент:</P>

<P><code>
<BR>$(<span class="STRING">"#mydiv"</span>).load(<span class="STRING">"/ajaxtest.php"</span>);
<BR></code></P>

<P>Мы выполняем запрос к файлу из первого примера про AJAX. После выполнения запроса в элемент с id="mydiv" будет записано слово «text».</P>

<P>
<H4>AJAJ</H4></P>

<P>Многие разработчики, столкнувшиеся с технологией AJAX, не любят передавать на клиент XML. Объясняется это тем, что XML может быть довольно большим по размеру, и существуют дополнительные трудности при разборе его структуры на клиенте. Благодаря jQuery, разбор XML на клиенте не представляет никакой сложности. А если разработчики активно используют AHAH, то и размеры передаваемого документа перестают быть решающим аргументом.</P>

<P>И все же многие предпочтут использовать JSON. JSON – это способ записи данных, который позволяет прогнать эту запись через функцию eval() и получить полноценный Javascript-объект. Для работы с данными в таком формате jQuery предлагает метод $.getJSON:</P>

<P><code>
<BR>getJSON(url, params, callback)
<BR></code></P>

<P>После выполнения запроса ответ с сервера прогоняется через функцию eval(), а полученный объект передается в функцию callback:</P>

<P><code>
<BR>&lt;?php
<BR>  <span class="KEYWORD">header</span>(<span class="STRING">'Content-Type: text/javascript; charset=utf-8'</span>);
<BR>?&gt;
<BR>{
<BR>  params: &lt;?php <span class="KEYWORD">echo</span> <span class="KEYWORD">$_REQUEST</span>[<span class="STRING">'params'</span>]; ?&gt;,
<BR>  response: <span class="STRING">'Наш ответ Чемберлену'</span>
<BR>}
<BR></code></P>

<P>Javascript:
<BR><code>
<BR>$.getJSON(
<BR>  '/ajaxtest3.php',
<BR>  {params: <span class="STRING">"text"</span>},
<BR>  onAjaxSuccess
<BR>);
<BR><span class="KEYWORD">function</span> onAjaxSuccess(obj)
<BR>{
<BR>  alert(obj.params);
<BR>  alert(obj.response);
<BR>}
<BR></code></P>

<P>
<H4>AJAJs</H4></P>

<P>Помимо трех вышеперечисленных способов получения данных с сервера jQuery предлагает еще один. С его помощью можно загрузить и выполнить любой сценарий Javascript с сервера. Для этого используется метод getScript:</P>

<P><code>
<BR>getScript(url[, callback])
<BR></code></P>

<P>Пример:</P>

<P>script.js</P>

<P><code>
<BR>$(<span class="STRING">"a"</span>).css(<span class="STRING">"color"</span>, <span class="STRING">"#0F0"</span>);
<BR></code></P>

<P>Наш Javascript:
<BR><code>
<BR>$.getScript('/script.js');
<BR></code></P>

<P>После выполнения этого метода будет загружен и выполнен сценарий script.js, который окрасит все ссылки на странице в зеленый цвет.</P>

<P>
<H3>Расширяемся...</H3></P>

<P>Главной особенностью библиотеки jQuery является ее расширяемость. Практически любой Web-разработчик может дополнить библиотеку своими методами, реализующими, например, свои эффекты или даже собственные селекторы (по типу :visible, :radio и т.п.). Писать модули, расширяющие функциональность jQuery, легко. Достаточно следовать нескольким простым правилам.</P>

<P>
<H4>Наименования</H4></P>

<P>Выберите название для своего плагина, например, «tester». Создайте .js-файл и назовите его jquery.tester.js.</P>

<P>
<H4>Добавляем собственный метод</H4></P>

<P>Чтобы добавить собственный метод, который будет доступен сразу из функции $(), достаточно добавить его в объект fn:</P>

<P><code>
<BR>jQuery.fn.tester = <span class="KEYWORD">function</span>() 
<BR>{
<BR>  alert(<span class="STRING">"Плагин работает!"</span>);
<BR>  <span class="KEYWORD">return</span> <span class="KEYWORD">this</span>;
<BR>};
<BR></code></P>

<P>Теперь в файле достаточно написать:</P>

<P><code>
<BR>&lt;script src=<span class="STRING">"jquery.js"</span>&gt;
<BR>&lt;script src=<span class="STRING">"jquery.tester.js"</span>&gt;
<BR>&lt;script&gt;
<BR>  $(<span class="STRING">"my-div"</span>).tester();
<BR>&lt;/script&gt;
<BR></code></P>

<P>и плагин заработает.</P>

<P>Обратите внимание, что в конце функции мы написали «return this;». Это необходимо для того, чтобы можно было создавать цепочки из методов.</P>

<P>
<H4>jQuery.extend</H4></P>

<P>Чаще всего пользователи захотят вызывать ваш плагин с какими-то настройками. Ну, например, в таком стиле:</P>

<P><code>
<BR>$(<span class="STRING">"my-div"</span>).tester(
<BR>  {
<BR>    name: <span class="STRING">"Test"</span>,
<BR>    value: <span class="STRING">"1"</span>
<BR>  }
<BR>);
<BR></code></P>

<P>Более того, вы захотите предоставить какие-то значения по умолчанию. Для этого можно использовать метод extend:</P>

<P><code>
<BR>$.extend(target, prop1, ..., propN)
<BR></code></P>

<P>Здесь:</P>

<P>
<UL>
<LI>target – начальный объект;</LI>
<LI>prop1-propN – объекты, свойства которых дополняют или изменяют свойства начальногообъекта.</LI>
</UL>Например:</P>

<P><code>
<BR><span class="KEYWORD">var</span> obj = {name: <span class="STRING">"Smith"</span>, profession: <span class="STRING">"Agent"</span>};
<BR><span class="KEYWORD">var</span> obj2 = {name: <span class="STRING">"Neo"</span>, profession: <span class="STRING">"The One"</span>};
<BR><span class="KEYWORD">var</span> obj3 = {second_job: <span class="STRING">"Virus"</span>};
<BR>
<BR>
<BR><span class="KEYWORD">var</span> neo     = $.extend(obj, obj2); <span class="COMMENT">// вернет {name: "Neo", profession: "The One"}</span>
<BR><span class="KEYWORD">var</span> a_smith = $.extend(obj, obj3); <span class="COMMENT">// вернет {name: "Smith", profession: "Agent", second_job: "Virus"};</span>
<BR></code></P>

<P>Таким образом, мы можем хранить в плагине значения по умолчанию и заменять их полученными от пользователя:</P>

<P><code>
<BR> jQuery.fn.tester = <span class="KEYWORD">function</span>(options) {
<BR>  <span class="COMMENT">// Значения по умолчанию</span>
<BR>  <span class="KEYWORD">var</span> settings = {txt: <span class="STRING">"Плагин работает!"</span>, txt2: <span class="STRING">""</span>};
<BR>
<BR>
<BR>  <span class="COMMENT">// Заменяем значения переданными</span>
<BR>  settings = jQuery.extend(settings, options);
<BR>
<BR>
<BR>  <span class="COMMENT">// Выводим новые значения</span>
<BR>     alert(<span class="STRING">"txt: "</span> + settings.txt + <span class="STRING">"\n txt2: "</span> + settings.txt2);
<BR> };
<BR></code></P>

<P>Теперь мы можем вызывать наш плагин с разными параметрами:</P>

<P><code>
<BR>$(<span class="STRING">"my-div"</span>).tester({txt: <span class="STRING">"Другой текст"</span>});
<BR>$(<span class="STRING">"my-div"</span>).tester({txt: <span class="STRING">"Другой текст"</span>, txt2: <span class="STRING">"Другой текст 2"</span>});
<BR></code></P>

<P>
<H4>Пример плагина</H4></P>

<P>Рассмотрим пример плагина из официальной документации по jQuery.</P>

<P>Этот плагин позволит нам писать следующее:</P>

<P><code>
<BR><span class="COMMENT">// Пометить флажком</span>
<BR>$(<span class="STRING">"input[@type='checkbox']"</span>).check('on');
<BR><span class="COMMENT">// Снять флажок</span>
<BR>$(<span class="STRING">"input[@type='checkbox']"</span>).check('off');
<BR><span class="COMMENT">// Переключить флажок</span>
<BR>$(<span class="STRING">"input[@type='checkbox']"</span>).check('toggle');
<BR></code></P>

<P>Вот как этот плагин реализован:</P>

<P><code>
<BR>jQuery.fn.check = <span class="KEYWORD">function</span>(mode) {
<BR>   <span class="COMMENT">// если mode не определен, используем 'on' по умолчанию</span>
<BR>   <span class="KEYWORD">var</span> mode = mode || 'on';
<BR>   
<BR>   <span class="COMMENT">// В функцию неявно передана коллекция выбранных элементов.</span>
<BR>   <span class="COMMENT">// Поэтому с этой коллекцией можно работать, как с любой другой</span>
<BR>   <span class="COMMENT">// коллекцией элементов в jQuery</span>
<BR>   <span class="COMMENT">// В нашем случае мы воспользуемся методом each()</span>
<BR>   <span class="KEYWORD">return</span> <span class="KEYWORD">this</span>.each(<span class="KEYWORD">function</span>() 
<BR><span class="KEYWORD">   </span>{
<BR>     <span class="KEYWORD">switch</span>(mode) {
<BR>       <span class="KEYWORD">case</span> 'on':
<BR>         <span class="KEYWORD">this</span>.checked = <span class="KEYWORD">true</span>;
<BR>         <span class="KEYWORD">break</span>;
<BR>       <span class="KEYWORD">case</span> 'off':
<BR>         <span class="KEYWORD">this</span>.checked = <span class="KEYWORD">false</span>;
<BR>         <span class="KEYWORD">break</span>;
<BR>       <span class="KEYWORD">case</span> 'toggle':
<BR>         <span class="KEYWORD">this</span>.checked = !<span class="KEYWORD">this</span>.checked;
<BR>         <span class="KEYWORD">break</span>;
<BR>     }
<BR>   });
<BR> };
<BR></code></P>

<P>
<H2>В заключение</H2></P>

<P>К сожалению, формат статьи не позволяет в полном объеме рассказать обо всех возможностях библиотеки jQuery и ее плагинах. Но, надеюсь, этой статьи будет достаточно, чтобы заинтересовать разработчиков. В кратком справочнике перечислены селекторы, используемые в jQuery, а также ссылки на интересные ресурсы и различные плагины.</P>

<P>
<H2>Краткий справочник</H2></P>

<P><A HREF="http://docs.jquery.com/DOM/Traversing/Selectors">http://docs.jquery.com/DOM/Traversing/Selectors</A></P>

<P>
<H3>CSS</H3></P>

<P>Поддерживаемые селекторы CSS</P>

<P><TABLE ><TR><TD>*</TD><TD>Элемент Е, являющийся n-ым дочерним элементом своего родительского элемента.</TD></TR><TR><TD>E</TD><TD>Элемент типа E.</TD></TR><TR><TD>E:nth-child(n)</TD><TD>Элемент Е, являющийся n-ым дочерним элементом своего родительского элемента.</TD></TR><TR><TD>E:first-child</TD><TD>Элемент Е, являющийся первым дочерним элементом своего родительского элемента.</TD></TR><TR><TD>E:last-child</TD><TD>Элемент Е, являющийся последним дочерним элементом своего родительского элемента.</TD></TR><TR><TD>E:only-child</TD><TD>Элемент E, являющийся единственным дочерним элементом своего родительского элемента.</TD></TR><TR><TD>E:empty</TD><TD>Элемент E, у которого нет дочерних элементов (включая текстовые узлы).</TD></TR><TR><TD>E:enabled</TD><TD>Активный элемент Е пользовательского интерфейса.</TD></TR><TR><TD>E:disabled</TD><TD>Неактивный элемент Е пользовательского интерфейса.</TD></TR><TR><TD>E:checked</TD><TD>Отмеченный элемент Е пользовательского интерфейса (например, радиокнопка).</TD></TR><TR><TD>E.warning</TD><TD>Элемент E с классом "warning" (class="warning").</TD></TR><TR><TD>E#myid</TD><TD>E с ID равным "myid" (выберет максимум один элемент).</TD></TR><TR><TD>E:not(s)</TD><TD>Элемент E, не соответствующий простому селектору s.</TD></TR><TR><TD>E F</TD><TD>Элемент F, являющийся потомком элемента E</TD></TR><TR><TD>E > F</TD><TD>Элемент F, являющимся дочерним элементом элемента E.</TD></TR><TR><TD>E + F</TD><TD>Элемент F, которому непосредственно предшествует элемент E.</TD></TR><TR><TD>E ~ F</TD><TD>Элемент F, которому предшествует элемент E.</TD></TR><TR><TD>E,F,G</TD><TD>Выбрать все элементы E, F и G.</TD></TR></TABLE>
<H4>Другие селекторы</H4></P>

<P>Все селекторы атрибутов должны записываться в стиле XPath, то есть с предваряющим символом «@»:</P>

<P><TABLE ><TR><TD>E[@foo]</TD><TD>элемент E с аттрибутом «foo».</TD></TR><TR><TD>E[@foo=bar]</TD><TD>Элемент E, у которого значение атрибута «foo» равно «bar».</TD></TR><TR><TD>E[@foo^=bar]</TD><TD>Элемент E, у которого значение атрибута «foo» начинается с «bar».</TD></TR><TR><TD>E[@foo$=bar]</TD><TD>Элемент E, у которого значение атрибута «foo» оканчивается на «bar».</TD></TR><TR><TD>E[@foo*=bar]</TD><TD>E, у которого значение атрибута «foo» содержит «bar».</TD></TR></TABLE>-Примеры использования
<BR><TABLE ><TR><TD>jQuery</TD><TD>Аналог из CSS</TD></TR><TR><TD>$(“#my-id”)</TD><TD>#my-id {}</TD></TR><TR><TD>$(“a.classname”)</TD><TD>a.classname {}</TD></TR><TR><TD>$(“p, div.myclass, a#my-id”)</TD><TD>p, div.myclass, a#my-id {}</TD></TR><TR><TD>$(“div:last-child”)</TD><TD>div:last-child {}</TD></TR><TR><TD>$(“*:checked”)</TD><TD>*:checked</TD></TR></TABLE>
<H3>XPath</H3></P>

<P>
<H4>Определение местоположения</H4></P>

<P>Абсолютные пути</P>

<P><code>
<BR> $(<span class="STRING">"/html/body//p"</span>)
<BR> $(<span class="STRING">"/*/body//p"</span>)
<BR> $(<span class="STRING">"//p/../div"</span>)
<BR></code></P>

<P>Относительные пути</P>

<P><code>
<BR> $(<span class="STRING">"a"</span>,<span class="KEYWORD">this</span>)
<BR> $(<span class="STRING">"p/a"</span>,<span class="KEYWORD">this</span>)
<BR></code></P>

<P>
<H4>Поддерживаемые селекторы по оси</H4></P>

<P>Потомок Элемент содержит потомков</P>

<P><code>
<BR> $(<span class="STRING">"//div//p"</span>)
<BR></code></P>

<P>Дочерний У элемента есть дочерний элемент</P>

<P><code>
<BR> $(<span class="STRING">"//div/p"</span>)
<BR></code></P>

<P>Предшествующий соседний элемент Элементу предшествует другой элемент на той же оси</P>

<P><code>
<BR> $(<span class="STRING">"//div ~ form"</span>)
<BR></code></P>

<P>Родитель Выбирает родительский элемент элемента</P>

<P><code>
<BR> $(<span class="STRING">"//div/../p"</span>)
<BR></code></P>

<P>Поддерживаемые предикаты</P>

<P>[@*] Содержит атрибут</P>

<P><code>
<BR> $(<span class="STRING">"//div[@*]"</span>)
<BR></code></P>

<P>[@foo] Содержит атрибут «foo»</P>

<P><code>
<BR> $(<span class="STRING">"//input[@checked]"</span>)
<BR></code></P>

<P>[@foo='test'] Атрибут «foo» равен «test»</P>

<P><code>
<BR> $(<span class="STRING">"//a[@ref='nofollow']"</span>)
<BR></code></P>

<P>[Nodelist] Элемент соддержит список узлов, например:</P>

<P><code>
<BR> $(<span class="STRING">"//div[p]"</span>)
<BR> $(<span class="STRING">"//div[p/a]"</span>)
<BR></code></P>

<P>
<H4>Предикаты, поддерживаемые по-другому</H4></P>

<P>[last()] или [position()=last()] становится :last</P>

<P><code>
<BR> $(<span class="STRING">"p:last"</span>)
<BR></code></P>

<P>[0] или [position()=0] становится :eq(0) или :first</P>

<P><code>
<BR> $(<span class="STRING">"p:first"</span>)
<BR> $(<span class="STRING">"p:eq(0)"</span>)
<BR></code></P>

<P>[position() < 5] становится :lt(5)</P>

<P><code>
<BR> $("p:lt(5)")
<BR></code></P>

<P>[position() > 2] становится :gt(2)</P>

<P><code>
<BR> $("p:gt(2)")
<BR></code></P>

<P>
<H3>Специальные селекторы</H3></P>

<P>jQuery поддерживает некоторые селекторы, которые не являются частью стандартов CSS или XPath, но их использование облегчает жизнь.</P>

<P><TABLE ><TR><TD>:even</TD><TD>Выбирает все четные элементы из коллекции.</TD></TR><TR><TD>:odd</TD><TD>Выбирает все нечетные элементы из коллекции.</TD></TR><TR><TD>:eq(0) и :nth(0)</TD><TD>Выбирает элемент с индексом N из коллекции.</TD></TR><TR><TD>:gt(4)</TD><TD>Выбирает элементы с индексом большим, чем N.</TD></TR><TR><TD>:lt(4)</TD><TD>Выбирает элементы с индексом меньшим, чем N.</TD></TR><TR><TD>:first</TD><TD>Эквивалентно :eq(0).</TD></TR><TR><TD>:last</TD><TD>Выбирает последний элемент из коллекции.</TD></TR><TR><TD>:parent</TD><TD>Выбирает все элементы, у которых есть дочерние элементы (включая текст).</TD></TR><TR><TD>:contains('test')</TD><TD>Выбирает все элементы, которые содержат текст.</TD></TR><TR><TD>:visible</TD><TD>Выбирает все видимые элементы (включая элементы со стилями «display» равными «block» или «inline», «visibility» равным «visible» а также элементы форм, не являющихся типа «hidden»).</TD></TR><TR><TD>:hidden</TD><TD>Выбирает все невидимые элементы (включая элементы со стилями «display» равными «none», «visibility» равным «hiden» а также элементы форм, являющихся типа «hidden»).</TD></TR></TABLE>
<BR>Примеры:</P>

<P><code>
<BR>$(<span class="STRING">"p:first"</span>).css(<span class="STRING">"fontWeight"</span>,<span class="STRING">"bold"</span>);
<BR>$(<span class="STRING">"div:hidden"</span>).show();
<BR>$(<span class="STRING">"div:contains('test')"</span>).hide();
<BR></code></P>

<P>
<H3>Селекторы форм</H3></P>

<P><TABLE ><TR><TD>:input</TD><TD>Выбирает все элементы формы (input, select, textarea, button).</TD></TR><TR><TD>:text</TD><TD>Выбирает все текстовые поля (type="text").</TD></TR><TR><TD>:password</TD><TD>Выбирает все поля для ввода паролей (type="password").</TD></TR><TR><TD>:radio</TD><TD>Выбирает все радиокнопки (type="radio").</TD></TR><TR><TD>:checkbox</TD><TD>Выбирает все флаговые поля (type="checkbox").</TD></TR><TR><TD>:submit</TD><TD>Выбирает все кнопки для отсылки формы (type="submit").</TD></TR><TR><TD>:image</TD><TD>Выбирает все изображения на форме (type="image").</TD></TR><TR><TD>:reset</TD><TD>Выбирает все кнопки очистки формы (type="reset").</TD></TR><TR><TD>:button</TD><TD>Выбирает все остальные кнопки (type="button").</TD></TR></TABLE>
<BR>Примеры:</P>

<P><code>
<BR>$("#myForm :input")
<BR>$("input:radio", myForm)
<BR></code></P>

<P>
<H2>Трюки</H2></P>

<P>
<H4>Совместимость</H4></P>

<P>Возможно, вы уже используете другие библиотеки Javascript, которые также используют знак доллара для своих нужд. Чтобы избежать конфликтов с такими библиотеками, вместо знака доллара достаточно использовать функцию jQuery:</P>

<P><code>
<BR>jQuery(<span class="STRING">"#myid"</span>); <span class="COMMENT">// Эквивалентно $("#myid");</span>
<BR></code></P>

<P>Самой библиотеке jQuery можно запретить использование знака доллар:</P>

<P><code>
<BR>&lt;script src=<span class="STRING">"prototype.js"</span>&gt;
<BR>&lt;script src=<span class="STRING">"jquery.js"</span>&gt;
<BR>&lt;script&gt;
<BR>jQuery.noConflict();
<BR>
<BR>      
<BR><span class="COMMENT">// Дальше используем jQuery через jQuery(...)</span>
<BR>jQuery(<span class="STRING">"#myid"</span>).hide();
<BR>
<BR>
<BR><span class="COMMENT">// Используем Prototype через $(...)</span>
<BR>$('myid').addClassName('active').show();
<BR>&lt;/script&gt;
<BR></code></P>

<P>
<H4>Определение браузеров</H4></P>

<P>Используйте объект $.browser:</P>

<P><code>
<BR><span class="KEYWORD">if</span>($.browser.ie)...
<BR><span class="KEYWORD">if</span>($.browser.mozilla)...
<BR></code></P>

<P>
<H4>Ускорение выборки</H4></P>

<P>Для поиска элемента по id используйте только id. Для поиска элементов по классу используйте название элемента и название класса:</P>

<P><code>
<BR>$(<span class="STRING">"#my-div"</span>)     <span class="COMMENT">// Не используйте $("div#mydiv");</span>
<BR>$(<span class="STRING">"div.div-class"</span>)   <span class="COMMENT">// Не используйте $(".div-class");</span>
<BR></code></P>

<P>Это связано с тем, что для поиска по id jQuery использует функцию getElmentById. Если использовано имя элемента, то jQuery сначала найдет все элементы с таким именем, и только потом начнет в них искать требуемый id. С классом ситуация обратная. Если имя элемента не указано, jQuery придется пробежаться по всем элементам в документе в поисках требуемого класса.</P>

<P>
<H4>Отладка AJAX</H4></P>

<P>Главная проблема в работе с технологией AJAX – сложность в определении возникающих ошибок. Незаменимым помощником в этом деле является Firebug – расширение для браузера Firefox. Это расширение позволяет отслеживать отсылаемые и получаемые запросы, проводить отладку скриптов и многое другое. Скачать это расширение можно с сайта <A HREF="http://getfirebug.com/">http://getfirebug.com/</A></P>

<P>
<H2>Ссылки и библиография</H2></P>

<P>
<H3>jQuery</H3>
<BR>
<UL>
<LI><A HREF="http://jquery.com/">http://jquery.com/</A> – официальный сайт jQuery</LI>
<LI><A HREF="http://visualjquery.com/">http://visualjquery.com/</A> – документация по jQuery в удобном виде</LI>
<LI><A HREF="http://docs.jquery.com/Tutorials">http://docs.jquery.com/Tutorials</A> – ссылки на различные учебные материалы по jQuery</LI>
</UL>
<H3>Плагины</H3>
<BR>
<UL>
<LI><A HREF="http://interface.eyecon.ro/">http://interface.eyecon.ro/</A> – библиотека всевозможных эффектов и элементов интерфейса</LI>
<LI><A HREF="http://www.malsup.com/jquery/form/">http://www.malsup.com/jquery/form/</A> – плагин, облегчающий работу с формами и технологией AJAX</LI>
<LI><A HREF="http://www.stilbuero.de/jquery/tabs">http://www.stilbuero.de/jquery/tabs</A> – плагин для создания табов</LI>
<LI><A HREF="http://jquery.com/demo/thickbox/">http://jquery.com/demo/thickbox/</A> – плагин для показа различной информации в «диалоге» внутри окна браузера</LI>
</UL>
<H3>Разное</H3>
<BR>
<UL>
<LI><A HREF="http://www.webdevout.net/browser_support.php">http://www.webdevout.net/browser_support.php</A> – подробный анализ совместимости популярных браузеров с Web-стандартами.</LI>
<LI><A HREF="http://getfirebug.com/">http://getfirebug.com/</A> – расширение для браузера Firefox, незаменимый помощник в отладке скриптов.</LI>
<LI><A HREF="http://jquery.com/blog/2006/10/18/zebra-table-showdown/">http://jquery.com/blog/2006/10/18/zebra-table-showdown/</A> – пример с раскрашиванием таблицы. Показаны решения, использующие и другие библиотеки.</LI>
<LI><A HREF="http://prototypejs.org/">http://prototypejs.org/</A> – упоминаемая в статье библиотека Prototype.</LI>
</UL><I>Эта статья опубликована в журнале RSDN Magazine #1-2007. Информацию о журнале можно найти здесь</I>    </P>
</BODY>
</HTML>