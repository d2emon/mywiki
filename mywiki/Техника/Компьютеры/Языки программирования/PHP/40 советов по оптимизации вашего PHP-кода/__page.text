!! 40 советов по оптимизации вашего PHP-кода

# Если метод может быть статическим, объявляйте его статическим.
# echo быстрее, чем print.
# Передавайте в echo несколько параметров, вместо того, чтобы использовать конкатенацию строк.
# Устанавливайте максимальное количество проходов ваших циклов for до цикла, а не во время его выполнения.
# Удаляйте свои переменные для освобождения памяти, тем более, если это большие массивы.
# Остерегайтесь магических методов, таких как __set, __get, __autoload.
# require_once дорого обходится.
# Указывайте полные пути в конструкциях include/require, меньше времени будет тратится на поиск файла.
# Если вам необходимо определить время, когда скрипт был запущен, используйте $_SERVER[’REQUEST_TIME’] вместо time().
# Старайтесь использовать strncasecmp, strpbrk и stripos вместо регулярных выражений.
# str_replace быстрее, чем preg_replace, но strtr быстрее, чем str_replace.
# Если функция, как и функции замены строк, может принимать в аргументы как массивы, так и одиночные символы, и если ваш список аргументов не слишком длинный, подумайте над тем, чтобы записать несколько одинаковых выражений замены, проходя один символ за раз, вместо одной строки кода, которая принимает массив как аргумент поиска и замены
# Лучше выбирать утверждения при помощи конструкции else if, чем использовать несколько конструкций if.
# Подавление ошибок при использовании @ работает очень медленно.
# Используйте модуль Apache mod_deflate.
# Закрывайте свои соединения с БД, когда закончите работать с ними.
# $row['id'] в семь раз быстрее, чем $row[id].
# Сообщения об ошибках дорого стоят
# Не используйте функции внутри условия цикла for, например как здесь: for ($x=0; $x < count($array); $x). В данном случае функция count() будет вызываться с каждым проходом цикла.
# Инкремент локальной переменной в методе - самый быстрый. Почти также работает инкремент локальной переменной в функции.
# Инкремент глобальной переменной в два раза медленее, чем локальной.
# Инкремент свойства объекта (т.е. $this->prop++) в три раза медленнее, чем локальной переменной.
# Инкремент неопределённой переменной в 9-10 раз медленнее, чем заранее инициализированной.
# Объявление глобальной переменной, без использования её в функции, также замедляет работу (примерно на ту же величину, что и инкремент локальной переменной). Вероятно, PHP осуществляет проверку на существование переменной.
# Скорость вызов метода, судя по всему, не зависит от количества методов, определённых в классе. Я добавил 10 методов в тестовый класс (до и после тестового метода), без изменения производительности.
# Методы в производных классах работают быстрее, чем они же, определённые в базовом классе.
# Вызов функции с одним параметром и пустым телом функции в среднем равняется 7-8 инкрементам локальной переменной ($localvar++). Вызов похожего метода, разумеется, около 15 инкрементов.
# Ваши строки, определённые при помощи ', а не ", будут интерпретироваться чуть быстрее, т.к. PHP ищет переменные внутри "..", но не '...'. Конечно, вы можете использовать это только тогда, когда в вашей строке нет переменных.
# Строки, разделённые запятыми, выводятся быстрее, чем строки, разделённые точкой. Примечание: это работает только с функцией echo, которая может принимать несколько строк в качестве аргументов.
# PHP-скрипты будут обрабатываться, как минимум, в 2-10 раз медленнее, чем статические HTML-страницы. Попробуйте использовать больше статических HTML-страниц и меньше скриптов.
# Ваши PHP-скрипты перекомпилируются каждый раз, если скрипты не кэшируются. Кэширование скриптов обычно увеличивает производительность на 25-100% за счёт удаления времени на компиляцию.
# Кэшируйте, насколько это возможно. Используйте memcached — это высокопроизводительная система кэширования объектов в памяти, которая повышает скорость динамических веб-приложений за счёт облегчения загрузки БД. Кэшированный микрокод полезен тем, что позволяет вашему скрипту не компилироваться снова для каждого запроса.
# При работе со строками, когда вам понадобится убедиться в том, что строка определённой длины, вы, разумеется, захотите использовать функцию strlen(). Эта функция работает очень быстро, ведь она не выполняет каких-либо вычислений, а лишь возвращает уже известную длину строки, доступную в zval-структуре (внутренняя структура C, используемая при работе с переменными в PHP). Однако потому, что strlen() — функция, она будет работать медленно за счёт вызова некоторых операций, таких как приведение строки в нижний регистр и поиска в хэш-таблице, только после которых будут выполнены основные действия функции. В некоторых случаях вы сможете ускорить свой код за счёт использования хитрости с isset().[[<<]]Было: if (strlen($foo) < 5) { echo "Foo is too short"; }[[<<]]Стало: if (!isset($foo{5})) { echo "Foo is too short"; }[[<<]]Вызов isset() быстрее, чем strlen() потому, что, в отличие от strlen(), isset() - не функция, а языковая конструкция. За счёт этого isset() не имеет практически никаких накладных расходов на определение длины строки.
# Инкремент или декремент переменной при помощи $i++ происходит немного медленнее, чем ++$i. Это особая специфика PHP, и не нужно таким образом модифицировать свой C и Java-код думая, что он будет работать быстрее, этого не произойдёт. ++$i будет быстрее в PHP потому, что вместо четырёх команд, как в случае с $i++, вам понадобится только три. Пост-инкремент обычно используется при создании временных переменных, которые затем увеличиваются. В то время, как пре-инкремент увеличивает значение оригинальной переменной. Это один из способов оптимизации PHP-кода в байт-код утилитой Zend Optimizer. Тем не менее, это хорошая идея, поскольку не все байткод-оптимизаторы оптимизируют это, также остаётся немало скриптов, работающих без оптимизации в байткод.
# Не всё должно быть ООП, часто это излишне, поскольку каждый метод и объект занимает много памяти.
# Не определяйте каждую структуру данных как класс, массивы бывают очень полезны
# Не слишком разбивайте методы. Думайте, что вы действительно будете повторно использовать.
# Вы всегда можете разбить код на методы позже, по необходимости.
# Используйте бесчисленное количество предопределённых функций.
# Если в вашем коде есть функции, выполняющиеся очень долго, обдумайте их написание на C в виде расширения
# Профилируйте свой код. Профилирование покажет вам, как много времени выполняются части вашего кода.
# mod_gzip — модуль Apache, который позволяет сжимать ваши данные на лету и может уменьшить объем передаваемых данных до 80%.