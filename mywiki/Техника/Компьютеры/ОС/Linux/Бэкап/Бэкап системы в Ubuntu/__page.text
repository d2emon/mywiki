!! Бэкап системы в Ubuntu

!!!! Предисловие:

Часто бывает так, что, установив огромное количество программ (игр, скриптов и т.д.), приходит мысль: «Как мне дальше жить с этим мусором   ». Мы расстраиваемся, впадаем в депрессию из-за того, что нельзя всё вернуть обратно, как это было в недалёкие времена, когда система летала как ласточка и, работа за компьютером доставляла удовольствие.  И тогда на помощь приходит такое понятие как Бэкап системы (или Резервное копирование). Подробно рассмотрим один из способов, как сделать резервную копию нашей системы, с возможностью последующего восстановления.

Обратите особое внимание на всё, что написано курсивом. Таким образом буду указывать важные указания, пометки или рекомендации. Стоит дословно ознакомиться со всей статьёй сразу, чтобы избежать каких либо ошибок в будущем.

!!!! Подготовка:

Итак, у нас есть установленная система: Ubuntu, установочный диск с возможностью загрузки системы без установки, и место, куда мы сохраним архив с Ubuntu (флешка или жесткий диск).

Следует заметить, что свободного места на флешке или жестком диске должно хватить для того, чтобы разместить архив (свеже-установленная система «весит» максимум 3 гигабайта; т.е. примерный вес архива, с учетом сжатия, будет иметь «вес» 1.5 гигабайта).

Для начала запустим установочный диск с Ubuntu, и после выбора языка, запускаем «убунту» без установки (Запустить Ubuntu без установки):

После полной загрузки приступаем к следующему этапу:

!!!! Бэкап:

Запускаем консоль (терминал) сочетанием клавиш:

@@
Ctrl+Alt+T
@@

Либо через меню:

Открылся терминал:

Последний символ приветствия строки в терминале: $, означает, что все последующие действия будут от имени действующего пользователя ubuntu.

Теперь для большинства следующих действий потребуются права владельца, поэтому выполняем команду:

@@
$ sudo -s
@@

И теперь последний символ строки будет: # , что означает — права владельца.

Далее выполним команду:

@@
# fdisk -l
@@

для того, чтобы вывести список всех жестких дисков.

Примерный результат выполнения данной команды:

На скриншоте мы видим два жестких диска: /dev/sda и /dev/sdb.

Внимательно следите за буквами и номерами разделов!

На примере: /dev/sda — диск для размещения бэкапа.

/dev/sdb — диск с разделами Linux (нашей Ubuntu) и swap (раздел для «подкачки»).

Если Вы также будете использовать сторонний ЖД (жесткий диск), то подключить его необходимо еще до загрузки компьютера (при выключенном питании). Если же использовать флешку или USB ЖД, то будет немного легче (меньше манипуляций).

Теперь примонтируем необходимые разделы. Судя по примеру, раздел с Ubuntu находится на диске /dev/sdb в разделе /dev/sdb1. Поэтому примонтируем раздел с «убунтой» в какую нибудь папку (перед этим создадим её):

@@
# mkdir /media/bubunta
@@

Создали папку /media/bubunta.

@@
# mount /dev/sdb1 /media/bubunta
@@

Примонтировали «убунту» в папку /media/bubunta.

Следующий пункт, для тех кто будет использовать сторонний ЖД вместо флешки (или USB ЖД):

Также монтируем раздел для бэкапа в папку (перед этим создадим её):

@@
# mkdir /media/backup
# mount /dev/sda1 /media/backup
@@

Теперь проверим наличие созданных нами папок (и ради интереса проверим и размер папок):

@@
# ls /media
# du -sh /media/*
@@

Создадим файл со списком дирректорий, которые не хотелось бы бэкапить:

@@
# gedit /media/backup/exclude
@@

Если используем флешку или USB ЖД, то указываем другие пути.

И запишем следующие дирректории (данные дирректории обязательны!):

@@
proc/*
sys/*
tmp/*
@@

Если у вас есть папки, которые Вы бы не хотели бэкапить, то также занесите и их в этот список.

Нажмите кнопку Save, чтобы сохранить файл, и закройте окно редактора.

Далее перейдем в папку с Ubuntu, для последующего создания бэкапа:

@@
# cd /media/bubunta
@@

Перед тем, как приступить к архивации, выньте все сторонние устройства из компьютера.

И приступим к архивации:

@@
# tar -X /media/backup/exclude -czf /media/backup/backup.tgz *
@@

* Флагом -X указываем путь к файлу (/media/backup/exclude), исключающего список дирректорий для архивации;
* Флагом -czf: с — создание архива;
* z — gzip способ архивации;
* f — для указания пути архива;

Остается только ждать, пока закончится архивация 

И на этом всё. Архив готов. Теперь можно хранить архив, до неблагоприятных времен.

Соберу все команды в небольшой список, для того чтобы удобно было распечатать:
Выражаю огромную благодарность Артёму (ShiftBHT), за любезно предоставленный принцип резервного копирования системы и поправки в статье.

В связи с большим содержанием данной статьи, статью о восстановлении из архива, решил написать отдельно.

Спасибо за терпение и внимание!

''Данный способ подойдёт для всех дистрибьютивов) И можно бэкапить на рабочей системе, именно для этого и исключаются /tmp, /proc, /sys и желательно /dev''

''Если не сложно, — напишите как из полученного архива «в случае чего», восстановить систему.
Просьба наверняка ламерская, но я и есть он самый. http://gansik.ru/ubuntu/recovery-ubuntu/''

----

Как известно, «пользователи компьютера делятся на тех, кто делает бэкапы, и тех, кто будет их делать». В этой статье мы рассмотрим различные способы резервного копирования (бэкапа) всей системы и, соответственно, восстановления из резервной копии.

Сразу стоит отметить, что все операции стоит производить не «по-живому», т.е. не на работающей системе, а с liveCD или установленной на соседнем разделе/флэшке/usb-hdd системы. В случаях, когда простой в несколько минут критичен для системы, возможно копирование системы из-под самой себя, но при этом нужно учитывать некоторые дополнительные условия, которые в данной статье пока что не рассматриваются

Далее по тексту для действий, выполняемые от имени суперпользователя, будет использоваться команда sudo, что является стандартом для Ubuntu. В других системах возможно получение привелегий суперпользователя через su, некоторые liveCD-системы по умолчанию работают в режиме суперпользователя

!!! tar

Одним из наиболее популярных способов создания простейшего бэкапа является архивация данных с помощью tar. Преимуществами данного способа являются возможность инкрементного бэкапа (добавления файлов в существующий архив, удаления или изменения таковых), возможность извлечения из архива отдельных файлов, а также присутствие tar практически в любой Linux-системе.

!!!! Создание архива

Для начала создайте точки монтирования для корневого раздела и для раздела, на котором вы собираетесь создавать бэкап, например так

@@
sudo mkdir /mnt/{root,backup}
@@

Смонтируйте оба раздела. Для большей надежности можно смонтировать корневой раздел в режиме read-only (только для чтения), чтобы исключить вероятность случайного изменения данных

@@
sudo mount /dev/sdXY /mnt/root -o ro
sudo mount /dev/sdXY /mnt/backup
@@

(Вместо «sdXY» используйте ваши значения для нужных разделов. определить их можно с помощью sudo fdisk -l или sudo blkid)

В случае, если вы используете отдельные разделы для /boot, /usr, /home и пр. и хотите включить их содержимое в бэкап, примонтируйте их в соответствующие папки

@@
sudo mount /dev/sdXY /mnt/root/usr -o ro
sudo mount /dev/sdXY /mnt/root/home -o ro
@@

При необходимости создайте на бэкап-разделе папку, в которой вы хотите разместить архив, например

@@
sudo mkdir -p /mnt/backup/ubuntu/root
@@

Теперь можно приступить к созданию архива. Чтобы создать архив с gzip-сжатием, выполните

@@
sudo tar -cvzpf /mnt/backup/ubuntu-sda1.tar.gz /mnt/root
@@

(Ключ -p включает сохранение владельцев и прав доступа для файлов 1))

Для bzip2-сжатия используйте

@@
sudo tar -cvjpf /mnt/backup/ubuntu-sda1.tar.bz2 /mnt/root
@@

Для lzma-сжатия

@@
sudo tar --lzma -cvpf /mnt/backup/ubuntu-sda1.tar.lzma /mnt/root
@@

Аналогично для lzo-сжатия - ключ --lzop вместо --lzma

''Различные алгоритмы сжатия дают разный размер архива, а также отличаются по производительности''

По завершении процесса отмонтируйте все смонтированные разделы

@@
sudo umount /mnt/root{/boot,/var,/home,} /mnt/backup
@@

!!! Восстановление из архива

'''Внимание! Данный способ предполагает полный откат к состоянию на момент создания архива с заменой всех данных!'''

Создайте точки монтирования для корневого раздела и раздела, на котором хранится ваш архив

@@
sudo mkdir /mnt/{root,backup}
@@

Примонтируйте раздел с архивом-бэкапом

@@
sudo mount /dev/sdXY /mnt/backup -o ro
@@

Отформатируйте корневой раздел в ту же (или другую) ФС. Если вы используете отдельные разделы для /usr, /boot и пр. и архивировали их, отформатируйте их тоже

@@
sudo mkfs.reiserfs -l "root" /dev/sdXY
sudo mkfs.ext2 -L "boot" /dev/sdXY
sudo mkfs.ext4 -L "home" /dev/sdXY
@@

(если вы восстанавливаете систему на новый жесткий диск, разметьте его с помощью fdisk/gparted и отформатируйте разделы)

''Некоторые файловые системы поддерживают задание UUID при форматировании. Это дает возможность создать ФС с таким же UUID, как у старой, что позволит избежать необходимости править fstab.

Для ext2/3/4 UUID задается с помощью ключа -U, а еще больше упростить задачу можно командой вида

@@
sudo mkfs.ext4 -L "label" -U "$(sudo blkid -o value -s UUID /dev/sda1)" /dev/sda1
@@

Для reiserfs это будет ключ -u, для reiser4 -U, для остальных см. man mkfs.тип''

Смонтируйте свежесозданные ФС

@@
sudo mount /dev/sdXY /mnt/root
sudo mount /dev/sdXY /mnt/root/home
@@

Теперь можно распаковать содержимое архива на место

@@
sudo tar --same-owner -xvpf /mnt/backup/ubuntu-2010-10-07.tar.bz2 -C /mnt/root
@@

(ключ -C задает каталог, в который нужно распаковать файлы. ключ --same-owner сохраняет владельцев файлов при распаковке)

Если вы воспользовались советом выше и создали ФС тех же типов с теми же UUID - можете смело пропустить этот пункт. В противном случае вам придется исправить fstab в соответствии с произведенными изменениями. Откройте этот файл в любимом текстовом редакторе (например, nano) и замените UUID (и тип ФС, если форматировали что-либо в другую ФС) нужных разделов

@@
sudo nano /mnt/root/etc/fstab
@@

Сохраните файл, выйдите из редактора и отмонтируйте все смонтированные разделы

@@
sudo umount /mnt/root{/var,/boot,} /mnt/backup
@@

''Если вы распаковывали бэкап на другой жесткий диск, не забудьте установить туда GRUB!''

!!! dd - копирование раздела

dd - достаточно универсальная программа, применяемая для всевозможных целей. Здесь мы рассмотрим бэкап раздела диска с ее помощью. Сразу стоит отметить, что данный способ принципиально отличается от других тем, что dd работает не с файловой системой (и файлами на ней), а напрямую с данными, записанными в заданную область жесткого диска.

Данный метод имеет следующие преимущества:

* полное сохранение прав доступа, xattr (расширенные атрибуты файлов), acl и прочих атрибутов файлов - раздел копируется вместе с файловой системой и всем ее содержимым в том виде, в каком данные записаны на диск
* универсальность - dd присутствует в любой Linux-системе
* возможность копирования разделов с экзотическими ФС (например, Reiser4)
* возможность работы с образом как с реальным разделом

Однако, есть целый ряд недостатков:

* если файловая система содержит ошибки, после восстановления из такого бэкапа вы получите ФС с теми же ошибками
* для распаковки такого бэкапа потребуется раздел объемом не меньше исходного, вне зависимости от количества занятого места на разделе
* копируется все содержимое раздела, будь то ваши файлы или просто свободное место, что сказывается на скорости
* необходимость дополнительных манипуляций при распаковке на раздел большего размера
* нестандартный сопособ получения информации о процессе работы утилиты

Учитывая вышеизложенное можно сказать, что dd - не самый лучший инструмент в данном случае. С другой стороны, в освоении и использовании он проще многих других средств.

!!!! Создание образа

Нельзя допускать, чтобы данные на разделе изменялись во время копирования, иначе данные в образе будут противоречивы, а сам бэкап — бесполезен. Можно выбать один из следующих вариантов:

# Раздел отмонтирован (как в этой статье)
# Раздел смонтирован только для чтения
# Используются снапшоты (например, с помощью LVM)

Создайте точки монтирования для корневого и бэкап-разделов

@@
sudo mkdir /mnt/{root,backup}
@@

Смонтируем раздел для бэкапа

@@
sudo mount /dev/sdXY /mnt/root
@@

Теперь мы применим одну хитрость - прочистим свободное место от старого мусора (остатков удаленных файлов), перезаписав его нулевыми (пустыми) байтами. Эта операция не обязательна, но может заметно помочь при сжатии образа. Если сжимать образ не требуется, то следующие четыре команды вам не нужны.

@@
sudo mount /dev/sdXY /mnt/backup
sudo dd if=/dev/zero of=/mnt/root/zero bs=4M
@@

(Опция if задает входной файл, в данном случае это /dev/zero - псевдоустройство, генерирующее поток нулевых байтов; опция of - выходной файл, в которые записываются наши данные; bs задает размер блока, т.е. количество информации, считываемой/записываемой за один раз - в данном случае это 4МБ)

Под конец процесса dd завершится с ошибкой - это нормально, потому что генератор нулей у нас бесконечный, а место на диске не резиновое. Теперь удалите полученный файл

@@
sudo rm -v /mnt/root/zero
@@

Отмонтируйте корневой раздел

@@
sudo umount /mnt/root
@@

Все, можно приступать к процессу

@@
sudo dd if=/dev/sdXY bs=1M conv=noerror | gzip -c > /mnt/backup/root.dd.gz
@@

sdXY - ваш корневой раздел. (в данном примере мы используем немного усложненный вариант - по мере копирования сразу же пропускаем данные через архиватор, в итоге получая уже сжатый образ. вместо gzip вы можете применить lzma или другой архиватор на ваш выбор. также можете поэкспериментировать с размером блока - данная опция влияет на производительность. с опцией conv=noerror процесс не будет прекращен при ошибке чтения/записи)

''знающие люди, распишите кто-нибудь про оптимальный подбор bs (что конкретно оно дает),

[i|o]bs - размер блока при работе с потоком. ibs - размер блока при чтении, obs - размер блока при записи, bs - устанавливает оба значения сразу. Рекомендуется ставить кратным степени двойки, умноженной на размер кластера файловой системы (обычно это 4096 байт). Для современных жестких дисков 1Мб - это нормально, но значения, бОльшие 64кб, на мой взгляд, не ускоряют операций с диском. — AnrDaemon 2012/03/12 22:40

а заодно про conv=sync (нужен ли он)

НЕТ!!!!!!!!!!!!!!!!!! Это может привести к повреждению результирующего образа. man dd для разнообразия? Там даже пример есть. На русском, если у вас русские маны стоят. А вот iflag=direct (либо, при записи на блочное устройство - oflag) при работе с блочными устройствами использовать стОит, чтобы не получить на выходе файл «образа» раз в 5 бОльше исходного раздела. — AnrDaemon 2012/03/12 22:40

Понятно чем больше значение bs, тем бóльшими блоками данных будет оперировать dd и тем быстрее работа. Оптимальным для скорости считается размер блока, равным или чуть меньшим половины объёма кэша жесткого диска. Но нужно еще выяснить есть ли опасность задания слишком больших значений bs. Не известно есть ли возможность при большом параметре bs «зацепить» в образ одного раздела кусок следующего? И что случится при восстановлении раздела из такого образа? Не затронет ли dd соседний раздел?

Если не использовать копирование напрямую с диска (/dev/sdL), а работать с разделами (/dev/sdLN) или файлами (ранее созданными резервными копиями), и не использовать ненужных опций, типа conv=sync - никакой опасности нет. Чтение просто остановится в конце файла(устройства). — AnrDaemon 2012/03/12 22:41''

Для слабых компьютеров имеет смысл применить вариант без архивации «на лету»

@@
sudo dd if=/dev/sdXY of=/mnt/backup/root.dd bs=1M conv=noerror
@@

При желании вы сможете позже сжать образ с помощью любого архиватора на другом компьютере

dd работает весьма «молчаливо», но есть хитрый способ узнать о ходе процесса. В соседней tty-консоли (обычно переключаются по Alt + F1 … Alt + F6) или новой вкладке графического терминала выполните

@@
killall -s USR1 dd
@@

Теперь вернитесь на вкладку/консоль с dd - там вы увидите информацию об объеме скопированных данных и скорости записи.

Если вы хотите видеть вывод данных о работе dd постоянно (через определенные промежутки времени), то во второй консоле следует ввыполнить:

@@
sudo watch -n2 killall -SIGUSR1 dd
@@

в параметре -n2 — 2 означает выполнять команду каждые две секунды.

Повторите все этапы для отдельных разделов (/boot, /usr и пр.), если таковые имеются.

По завершении процесса отмонтируйте бэкап-раздел

@@
sudo umount /mnt/backup
@@

!!!! Восстановление раздела из образа

'''Внимание! Данный способ предполагает полный откат к состоянию на момент создания архива с заменой всех данных!'''

Смонтируйте раздел с образом-бэкапом

@@
sudo mount /dev/sdXY /mnt
@@

Собственно, можно приступать (дополнительных манипуляций вроде форматирования раздела в данном случае не требуется)

@@
gzip -dc /mnt/root.dd.gz | dd of=/dev/sdXY bs=1M conv=noerror
@@

Или же для несжатого образа

@@
sudo dd if=/mnt/root.dd of=/dev/sdXY bs=1M conv=noerror
@@

(в обоих случаях sdXY - ваш корневой раздел)

''Если вы хотите распаковать систему на новый жесткий диск, разметьте его с помощью fdisk/gparted/etc (чем умеете), создав корневой раздел того же размера (или больше, главное - не меньше). В случае, если новый раздел больше исходного, вам потребуется после распаковки расширить раздел с помощью parted/gparted, а также ФС на разделе (не все ФС поддерживают увеличние размера!)''

''Если вы распаковывали бэкап на другой жесткий диск, не забудьте установить туда GRUB!''

!!!! Монтирование образа

С образом раздела, сделанным с помощью dd можно работать как с настоящим разделом, т.е. записывать на него файлы, удалять или изменять существующие и т.д. Для этого нужно лишь смонтировать образ как loop-устройство

Если вы применяли архивацию при создании файла-образа, сначала распакуйте его с помощью того же архиватора, например

@@
bzip2 -dv /media/backup/sda5.dd.bz
@@

Теперь можно смонтировать образ

@@
sudo mount /media/backup/sda5.dd -o loop /mnt
@@

(С опцией loop программа mount автоматически «подцепит» файл-образ на свободное loop-устройство, после чего смонтирует файловую систему)

Теперь вы можете работать с содержимым образа как с обычной файловой системой, все ваши изменения запишутся в образ. По завершении работы отмонтируйте образ как обычную ФС

@@
sudo umount /mnt
@@

!!! dd - копирование всего жесткого диска

В данном случае мы снова воспользуемся dd, только на сей раз сохраним все содержимое жесткого диска - с таблицей разделов, самими разделами и всеми данными. Преимущество данного метода в том, что можно за один шаг сохранить все установленные на этом жестком диске системы без необходимости бэкапить каждый раздел отдельно. Кроме того, при таком бэкапе сохранятся все данные, относящиеся к загрузчику - таким образом, после восстановления из бэкапа вам не нужны будут дополнительные манипуляции, вы сможете сразу же загрузиться с этого жесткого диска.

!!!! Создание образа

В целом процедура аналогична описанной выше для бэкапа отдельных разделов. В данном случае также применим совет о прочистке свободного места «нулями» - при наличии свободного времени проделайте это со всеми разделами.

Перед началом операции убедитесь, что ни один из разделов данного жесткого диска не смонтирован. Сделать это можно запустив команду mount без параметров.

Выберите раздел, на котором вы собираетесь разместить файл-обарз. Разумеется, это должен быть раздел другого жесткого диска. Также убедитесь в наличии достаточного количества свободного места на этом разделе (например, с помощью утилиты df) - объем свободного места должен соответствовать объему копируемого жесткого диска (при сжатии образ получится меньше, но это зависит от типа хранимых данных).

Смонтируйте бэкап-раздел

@@
sudo mount /dev/sdXY /mnt
@@

Теперь можно приступать

@@
sudo dd if=/dev/sdX bs=1M conv=noerror,sync | lzma -cv > /mnt/hdd.dd.lzma
@@

(здесь «sdX» - диск, а не раздел! для копирования без сжатия команда аналогична приведенной выше для бэкапа раздела)

В зависимости от размера жесткого диска и производительности компьютера процедура может занять продолжительное время (до нескольких часов). По завершении отмонтируйте бэкап-раздел

@@
sudo umount /mnt
@@

!!!! Восстановление из образа

'''Внимание! Данный способ предполагает полный откат к состоянию на момент создания архива с заменой всех данных!'''

'''Перед началом работы убедитесь в надежности электропитания. Подключите сетевой адаптер, если у вас ноутбук, а также по возможности используйте ИБП или стабилизатор. При высокой интенсивности записи возрастает риск повреждения диска в случае сбоя питания'''

Убедитесь, что ни один раздел восстанавливаемого диска не используется. Смонтируйте бэкап-раздел

@@
sudo mount /dev/sdXY /mnt
@@

Можно приступать к процедуре

@@
bzip2 -dc /mnt/hdd.dd.bz | sudo dd of=/dev/sdX bs=1M conv=sync,noerror
@@

Или же для несжатого образа

@@
sudo dd if=/mnt/hdd.dd.bz of=/dev/sdX bs=1M conv=sync,noerror
@@

По завершении отмонтируйте бэкап-раздел

@@
sudo umount /mnt
@@

''Если вы хотите распаковать образ на другой жесткий диск, он должен иметь размер не меньше оригинального. В случае, если новый диск большего объема, вы сможете расширить разделы либо создать новый раздел на свободном месте с помощью parted/fdisk/gparted/etc''

''Не используйте оба жестких диска («дубликат» и «оригинал») одновременно! При подключении обоих дисков в системе будет по два раздела на каждый UUID, что приведет к проблемам в работе или невозможности загрузки''

!!!! Монтирование образа

По аналогии с образом раздела вы можете работать с образом жесткого диска как с обычным жестким диском. В данном случае процедура несколько усложняется, поскольку образ содержит несколько разделов.

Если образ сжатый - распакуйте его. Теперь «подцепите» образ на loop-устройство

@@
sudo losetup -fv /media/backup/sda.dd
@@

(С ключом -f программа автоматически найдет свободное loop-устройство, иначе необходимо явно указывать его)

losetup выведет на экран имя использованного устройства - если вы не работаете с другим файлами-образами (iso, шифрованными контейнерами и пр.), это скорее всего будет /dev/loop0

Теперь мы имеем устройство, являющееся для системы жестким диском, но не имеем доступа к его разделам. Добраться до разделов поможет программа kpartx (может потребоваться установка одноименного пакета)

@@
sudo kpartx -av /dev/loop0
@@

(Ключ -a - добавить разделы для заданного устройства; -v - информативный вывод)

Программа выведет имена созданных устройств для разделов диска: loop0p1 для первого раздела, loop0p2 - для второго, по аналогии с разделами обычного диска. Файлы устройств будут находиться в папке /dev/mapper

Теперь можно работать с разделами и ФС на них. Например, смонтировать бывший sda5 и записать на него файлы

@@
sudo mount /dev/mapper/loop0p5 /mnt
@@

По заверешнии отмонтируйте раздел

@@
sudo umount /mnt
@@

Удалите устройства-разделы с помощью kpartx

@@
sudo kpartx -dv /dev/loop0
@@

и освободите loop-устройство

@@
sudo losetup -v -d /dev/loop0
@@

Все! Изменения записались, а ваш образ снова стал обычным файлом

!!! cp

Здесь мы рассмотрим бэкап с помощью утилиты cp, т.е. с использованием простого копирования. Вообще-то, это не самый оптимальный способ, и подходит он скорее для копирования системы на другой жесткий диск / раздел / компьютер, нежели для создания резервной копии.

С другой стороны, данный способ имеет ряд преимуществ:

* универсальность - cp вы найдете в любой Linux-системе
* низкая требовательность к ресурсам (вследствие отсутствия сжатия и простоты механизма)
* простота дальнейшей работы с резервной копией (добавления/изменения/удаления файлов, извлечения нужных данных и пр.)

!!!! Создание копии

Создайте точки монтирования для корневого и бэкап-разделов

@@
sudo mkdir /mnt/{root,backup}
@@

Смонтируйте оба раздела

@@
sudo mount /dev/sdXY -o ro /mnt/root
sudo mount /dev/sdXY /mnt/backup
@@

Смонтируйте разделы для /usr, /boot и пр., если таковые имеются

@@
sudo mount /dev/sdXY -o ro /mnt/root/home
@@

Создайте на бэкап-разделе папку для своего бэкапа

@@
sudo mkdir /mnt/backup/ubuntu
@@

Можно начинать

@@
sudo cp -av /mnt/root/* /mnt/backup/ubuntu
@@

(ключ -a включает копирование ссылок «как есть», сохранение всех возможных атрибутов файлов и рекурсивный режим. ключ -v - вывод информации о происходящем)

По завершении процесса отмонтируйте все разделы

@@
sudo umount /mnt/backup /mnt/root/{usr,home,}
@@

''В дальнейшем вы сможете заархивировать ваши данные любым удобным способом''

!!!! Восстановление из копии

'''Внимание! Данный способ предполагает полный откат к состоянию на момент создания архива с заменой всех данных!'''

Создайте точки монтирования для разделов

@@
sudo mkdir /mnt/{root,backup}
@@

Смонтируйте бэкап-раздел

@@
sudo mount /dev/sdXY -o ro /mnt/backup
@@

Отформатируйте корневой раздел и разделы /usr, /boot и пр., если таковые имеются. (Про форматирование разделов с сохранением UUID см. в разделе про tar)

@@
sudo mkfs.reiserfs -l "root" /dev/sdXY
sudo mkfs.ext2 -L "boot" /dev/sdXY
sudo mkfs.ext4 -L "home" /dev/sdXY
@@

Смонтируйте свежесозданные ФС

@@
sudo mount /dev/sdXY /mnt/root
sudo mount /dev/sdXY /mnt/root/usr
sudo mount /dev/sdXY /mnt/root/var
@@

Процесс копирования происходит аналогично, только в обратном направлении

@@
sudo cp /mnt/backup/ubuntu/* -av /mnt/root
@@

По завершении копирования отредактируйте fstab, исправив UUID разделов

@@
sudo nano /mnt/root/etc/fstab
@@

Отмонтируйте разделы

@@
sudo umount /mnt/backup /mnt/root/{usr,home,}
@@

''Если вы копировали данные на другой жесткий диск, не забудьте установить туда GRUB!''

!!! squashfs

squashfs - файловая система, создаваемая в виде файла-образа, использующая сжатие.

Она имеет целый ряд преимуществ, таких как:

* возможность работы со сжатым образом напрямую, без предварительной распаковки
* очень информативный вывод информации о ходе рабты
* возможность монтирования образа как обычной ФС (через loop-устройство)
* сохранение атрибутов файлов (прав доступа, владельцев, временных отметок, а с версии 4.1 также и xattr) по умолчанию
* поддержка файлов больших размеров (максимальный размер файла, как и самой ФС - 264 байт)
* оптимизаия под многоядерные процессоры

Из недостатков можно выделить следующее:

* невозможность удаления файлов из образа или изменения существующих (можно только добавлять файлы в образ)
* утилиты для работы с squashfs присутствуют не во всех дистрибутивах

Последний пункт означает, что для начала вам потребуется подобрать дистрибутив, содержащий пакет утилит для squashfs или же имеющий возможность установки из репозитория. В качестве примера можно предложить Parted Maigc, а вообще-то подойдет и liveCD Ubuntu, нужно будет просто установить пакет squashfs-tools

!!!! Создание образа

Cоздайте точки монтирования для корневого и бэкап-разделов

@@
sudo mkdir /mnt/{root,backup}
@@

Cмонтируйте оба раздела
@@
sudo mount /dev/sdXY -o ro /mnt/root
sudo mount /dev/sdXY /mnt/backup
@@

Cмонтируйте отдельные разделы для /boot, /usr и пр. (если имеются) в соответствующие папки

@@
sudo mount /dev/sdXY -o ro /mnt/root/home
@@

Все, можно приступать. Для создания образа используется утилита mksquashfs

@@
sudo mksquashfs /mnt/root /mnt/backup/ubuntu-root.sqfs -no-duplicates
@@

(С опцией -no-duplicates программа не будет исключать одинаковые по содержимому файлы. Многие программы используют пустые файлы для различных целей - без данной опции такие файлы не вошли бы в образ как дубликаты. Кроме того, можете поэкспериментировать с опцией -b - она задает объем данных, который будет считан/записан за один раз, до 1 МБ)

В отличие от многих других инструментов mksquashfs покажет индикатор прогресса с указанием процентов. По завершении программа также выведет информацию о количестве файлов/папок/ссылок, коэффициенте сжатия и пр.

Готово! Осталость лишь отмонтировать разделы

@@sudo umount /mnt/backup /mnt/root{/usr,/var,/home,}@@

Помимо стандартного gzip-сжатия squashfs также поддерживает lzo и lzma. Правда, для этого потребуются некоторые дополнительные манипуляции. Кому интересно - обращайтесь: dimas000

Кроме этого, можно создать образ и без сжатия - для этого используйте mksquashfs с опцией -noD

!!!! Восстановление из образа

'''Внимание! Данный способ предполагает полный откат к состоянию на момент создания архива с заменой всех данных!'''

Создайте точки монтирования для разделов

@@
sudo mkdir /mnt/{root.backup}
@@

Смонтируйте бэкап-раздел

@@
sudo mount /dev/sdXY -o ro /mnt/backup
@@

Отформатируйте корневой раздел и разделы /usr, /boot и пр., если таковые имеются. (Про форматирование разделов с сохранением UUID см. в разделе про tar)

@@
sudo mkfs.reiserfs -l "root" /dev/sdXY
sudo mkfs.ext2 -L "boot" /dev/sdXY
sudo mkfs.ext4 -L "home" /dev/sdXY
@@

Смонтируйте свежесозданные ФС

@@
sudo mount /dev/sdXY /mnt/root
sudo mount /dev/sdXY /mnt/root/usr
sudo mount /dev/sdXY /mnt/root/var
@@

Можно приступать! Для распаковки образа используется утилита unsquashfs

@@
sudo unsquashfs -d /mnt/root -f /mnt/backup/ubuntu-root.sqfs
@@

(Ключ -d задает путь для распаковки, с ключом -f программа будет использовать существующие папки вместо попыток создать новые)

Как и при создании образа, вы увидите индикатор прогресса и множество другой полезной информации.

По завершении отредактируйте fstab, заменив UUID разделов на новые (если вы форматировали разделы с теми же UUID, пропустите этот шаг)

@@
sudo nano /mnt/root/etc/fstab
@@

Сохраните файл и отмонтируйте все разделы

@@
sudo umount /mnt/backup /mnt/root{/usr,/var,}
@@

Если вы распаковывали бэкап на другой жесткий диск, не забудьте установить туда GRUB!

!!!! Монтирование образа

squashfs монтируется как любой другой образ - через loop-устройство. Поддержка squashfs ядром включена во множестве дистрибутивов, в том числе и в Ubuntu, так что достаточно будет просто воспользоваться командой mount с опцией loop

@@
sudo mount /media/backup/ubuntu-root.sqfs -o ro,loop /mnt
@@

(Опция ro не обязательна, т.к. записать туда все равно ничего не получится)

Теперь вы можете скопировать из образа любые нужные файлы. Добавить что-либо таким способом не получится, для этого нужно будет опять воспользоваться mksquashfs

По завершении отмонтируйте образ как обычную ФС

@@
sudo umount /mnt
@@

!!! rsync

Подобно cp, rsync работает с файлами, а не с блочными устройствами. Особенность rsync в том, что он не копирует файлы, которые уже есть в точке назначения. По умолчанию он проверяет размер и время изменения файлов, но можно проверять и хэш (обычно это делается, когда нужна повышенная безопасность).

Синтаксис rsync подобен cp:

@@
rsync -a /mnt/root /mnt/backup
@@

Параметра -a очень часто бывает достаточно, он обеспечивает самое нужное: рекурсивное копирование директорий, сохранение информации о владельце и группе и т.д. Для отображения подробной информации о копировании используется ключ -v, с ним будьте внимательны, в потоке данных можно пропустить сообщение об ошибке. Ключ -x гарантирует, что rsync не выйдет за пределы указанной файловой системы.

В документации к rsync описана масса параметров. Например, есть такие, которые позволяют выполнять копирование по SSH, или удаляют файл из точки назначения, если он был удалён в исходной директории.

«Умное» копирование позволяет сократить время простоя системы. Запускаем rsync прямо на работающей системе, данные в которой постоянно изменяется, rsync копирует данные, скажем, в течение нескольких часов. Затем переводим систему в read-only, снова запускаем rsync, теперь он копирует только те файлы, которые изменились за эти несколько часов. Через несколько минут мы имеем полную копию исходной ФС. Время простоя при этом сократилось на порядок по сравнению с оффлайн-копированием. А в некоторых случаях будет достаточно и одного онлайн-копирования без перевода системы в read-only.

!!! Прочие инструменты

Существует масса приложений для создания бекапов в Linux. Можно воспользоваться поиском по слову «backup» в Центре приложений Ubuntu, чтобы найти доступные в Ubuntu программы для работы с резервными копиями.

Для корпоративной среды и просто для достаточно масштабных и критичных заданий бекапа можно порекомендовать разобраться в одной из самых популярных и мощных систем резервного копирования для Linux, которая называется Bacula.

Также существуют различные LiveCD-дистрибутивы, специально предназначенные для резервного копирования данных. вот наиболее популярные из них:

!!!! CLonezilla

Clonezilla - универсальное средство для бэкапа разделов или целых дисков с гибкой настройкой процесса. Данный дистрибутив поддерживает множество файловых систем, работает с LVM2 и RAID-массивами (только аппаратные) и имеет локализацию для многих языков, включая русский. Clonezilla имеет понятный «пошаговый» псевдографический интерфейс, а решить возникающие вопросы поможет в изобилии доступная документация

!!!! Parted Magic

Parted Magic - еще один отличный дистрибутив, содержащий целую коллекцию средств для бэкапа и восстановления информации, работы с дисками и разделами, а также восстановления утерянных данных. Он поддерживает множество ФС, LVM2 и RAID (как аппаратный, так и программный) и содержит в себе таки средства как fsarchiver, GParted, вышеупомянтый Clonezilla, и все, что потребуется для описанных в этой статье способов. Кроме того, в состав дистрибутива входит веб-браузер и некоторое другое дополнительное ПО. Дистрибутив переведен на несколько языков, включая русский, и имеет полноценный графический интерфейс.

!!! Ещё немного о сохранении данных

Для важных данных можно сделать зеркальный раздел на двух дисках. Для этого совсем не обязательно иметь RAID-контроллер и диски одинакового размера — можно, например, собрать зеркало из 80-гигабайтного старого винта и 80-гигабайтного же раздела на новом. Зеркалирование можно реализовать с помощью LVM или программного RAID. Однако, такой способ бесполезен в случае, например, попадания на шину +5В напряжения ~220В или падения метеорита на системный блок компьютера.

Гики-айтишники, имеющие дома свой сервер, могут расширить идею зеркалирования и использовать DRBD. Тот же RAID-1, но жёсткие диски находятся в разных компьютерах, что повышает надёжность.

Современное удобное решение — бэкапить данные в «облака», например, с помощью Ubuntu One, Dropbox, http://www.adrive.com/ и других.

Ни зеркалирование, ни репликация на Ubuntu One не спасут от случайного нажатия Delete, поэтому в любом случае делайте «классические» бэкапы. И в один прекрасный ужасный день все ваши труды и старания будут вознаграждены.