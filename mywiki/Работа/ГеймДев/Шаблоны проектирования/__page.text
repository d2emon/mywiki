!! Шаблоны проектирования

Шаблон проектирования или паттерн (англ. design pattern) в разработке программного обеспечения — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

Обычно шаблон не является законченным образцом, который может быть прямо преобразован в код; это лишь пример решения задачи, который можно использовать в различных ситуациях. Объектно-ориентированные шаблоны показывают отношения и взаимодействия между классами или объектами, без определения того, какие конечные классы или объекты приложения будут использоваться.

«Низкоуровневые» шаблоны, учитывающие специфику конкретного языка программирования, называются идиомами. Это хорошие решения проектирования, характерные для конкретного языка или программной платформы, и потому не универсальные.

На наивысшем уровне существуют архитектурные шаблоны, они охватывают собой архитектуру всей программной системы.

Алгоритмы по своей сути также являются шаблонами, но не проектирования, а вычисления, так как решают вычислительные задачи.

!!! История

В 1970-е годы архитектор Кристофер Александр составил набор шаблонов проектирования. В области архитектуры эта идея не получила такого развития, как позже в области программной разработки.

В 1987 году Кент Бэк (Kent Beck) и Вард Каннингем (Ward Cunningham) взяли идеи Александра и разработали шаблоны применительно к разработке программного обеспечения для разработки графических оболочек на языке Smalltalk.

В 1988 году Эрих Гамма (Erich Gamma) начал писать докторскую диссертацию при цюрихском университете об общей переносимости этой методики на разработку программ.

В 1989—1991 годах Джеймс Коплин (James Coplien) трудился над разработкой идиом для программирования на C++ и опубликовал в 1991 году книгу Advanced C++ Idioms.

В этом же году Эрих Гамма заканчивает свою докторскую диссертацию и переезжает в США, где в сотрудничестве с Ричардом Хелмом (Richard Helm), Ральфом Джонсоном (Ralph Johnson) и Джоном Влиссидесом (John Vlissides) публикует книгу Design Patterns — Elements of Reusable Object-Oriented Software. В этой книге описаны 23 шаблона проектирования. Также команда авторов этой книги известна общественности под названием «Банда четырёх» (англ. Gang of Four, часто сокращается до GoF). Именно эта книга стала причиной роста популярности шаблонов проектирования.

!!! Плюсы

В сравнении с полностью самостоятельным проектированием, шаблоны обладают рядом преимуществ. Основная польза от использования шаблонов состоит в снижении сложности разработки за счёт готовых абстракций для решения целого класса проблем. Шаблон даёт решению своё имя, что облегчает коммуникацию между разработчиками, позволяя ссылаться на известные шаблоны. Таким образом, за счёт шаблонов производится унификация деталей решений: модулей, элементов проекта, — снижается количество ошибок. Применение шаблонов концептуально сродни использованию готовых библиотек кода. Правильно сформулированный шаблон проектирования позволяет, отыскав удачное решение, пользоваться им снова и снова. Набор шаблонов помогает разработчику выбрать возможный, наиболее подходящий вариант проектирования.

!!! Минусы

Хотя легкое изменение кода под известный шаблон может упростить понимание кода, по мнению Стива Макконнелла, с применением шаблонов могут быть связаны две сложности. Во-первых, слепое следование некоторому выбранному шаблону может привести к усложнению программы. Во-вторых, у разработчика может возникнуть желание попробовать некоторый шаблон в деле без особых оснований.

Многие шаблоны проектирования в объектно-ориентированном проектировании можно рассматривать как идиоматическое воспроизведение элементов функциональных языков. Питер Норвиг утверждает, что 16 из 23 шаблонов, описанных в книге «Банды Четверых», в динамически-типизируемых языках реализуются существенно проще, чем в С++, либо оказываются незаметны. Пол Грэхэм считает саму идею шаблонов проектирования — антипаттерном, сигналом о том, что система не обладает достаточным уровнем абстракции, и необходима её тщательная переработка[5]. Нетрудно видеть, что само определение шаблона как «готового решения, но не прямого обращения к библиотеке» по сути означает отказ от повторного использования в пользу дублирования. Это, очевидно, может быть неизбежным для сложных систем при использовании языков, не поддерживающих комбинаторы и полиморфизм типов, и это в принципе может быть исключено в языках, обладающих свойством гомоиконичности (хотя и не обязательно эффективно), так как любой шаблон может быть реализован в виде исполнимого кода[6].

!!! Типы шаблонов проектирования

!!!! Основные

!!!!! Основные шаблоны (Fundamental)

* Шаблон делегирования	Delegation pattern	Объект внешне выражает некоторое поведение, но в реальности передаёт ответственность за выполнение этого поведения связанному объекту.
* Шаблон функционального дизайна	Functional design	Гарантирует, что каждый модуль компьютерной программы имеет только одну обязанность и исполняет её с минимумом побочных эффектов на другие части программы.
* Неизменяемый интерфейс	Immutable interface	Создание неизменяемого объекта.
* Интерфейс	Interface	Общий метод для структурирования компьютерных программ для того, чтобы их было проще понять.д
* Интерфейс-маркер	Marker interface	В качестве атрибута (как пометки объектной сущности) применяется наличие или отсутствие реализации интерфейса-маркера. В современных языках программирования вместо этого могут применяться атрибуты или аннотации.
* Контейнер свойств	Property container	Позволяет добавлять дополнительные свойства для класса в контейнер (внутри класса), вместо расширения класса новыми свойствами.
* Канал событий	Event channel	Расширяет шаблон Publish/Subscribe, создавая централизованный канал для событий. Использует объект-представитель для подписки и объект-представитель для публикации события в канале. Представитель существует отдельно от реального издателя или подписчика. Подписчик может получать опубликованные события от более чем одного объекта, даже если он зарегистрирован только на одном канале.

!!!!! Порождающие шаблоны (Creational)

Порождающие шаблоны (Creational) — шаблоны проектирования, которые абстрагируют процесс инстанцирования. Они позволяют сделать систему независимой от способа создания, композиции и представления объектов. Шаблон, порождающий классы, использует наследование, чтобы изменять инстанцируемый класс, а шаблон, порождающий объекты, делегирует инстанцирование другому объекту.

* {+Абстрактная фабрика	Abstract factory+} Класс, который представляет собой интерфейс для создания компонентов системы.
* {+Строитель	Builder+}	Класс, который представляет собой интерфейс для создания сложного объекта.
* {+Фабричный метод	Factory method+}	Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать.
* Отложенная инициализация	Lazy initialization	Объект, инициализируемый во время первого обращения к нему.
* Пул одиночек	Multiton	Гарантирует, что класс имеет поименованные экземпляры объекта и обеспечивает глобальную точку доступа к ним.
* Объектный пул	Object pool	Класс, который представляет собой интерфейс для работы с набором инициализированных и готовых к использованию объектов.
* {+Прототип	Prototype+}	Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через конструктор.
* Получение ресурса есть инициализация	Resource acquisition is initialization (RAII)	Получение некоторого ресурса совмещается с инициализацией, а освобождение — с уничтожением объекта.
* {+Одиночка	Singleton+}	Класс, который может иметь только один экземпляр.

!!!!! Структурные шаблоны (Structural)

Структурные шаблоны (Structural) определяют различные сложные структуры, которые изменяют интерфейс уже существующих объектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.

* {+Адаптер	Adapter / Wrapper+}	Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс.
* {+Мост	Bridge+}	Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо.
* {+Компоновщик	Composite+}	Объект, который объединяет в себе объекты, подобные ему самому.
* {+Декоратор или Wrapper/Обёртка	Decorator+}	Класс, расширяющий функциональность другого класса без использования наследования.
* {+Фасад	Facade+}	Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.
* Единая точка входа	Front controller	Обеспечивает унифицированный интерфейс для интерфейсов в подсистеме. Front Controller определяет высокоуровневый интерфейс, упрощающий использование подсистемы.
* {+Приспособленец	Flyweight+}	Это объект, представляющий себя как уникальный экземпляр в разных местах программы, но фактически не являющийся таковым.
* {+Заместитель	Proxy+}	Объект, который является посредником между двумя другими объектами, и который реализует/ограничивает доступ к объекту, к которому обращаются через него.

!!!!! Поведенческие шаблоны (Behavioral)

Поведенческие шаблоны (Behavioral) определяют взаимодействие между объектами, увеличивая таким образом его гибкость.

* {+Цепочка обязанностей+}	Chain of responsibility	Предназначен для организации в системе уровней ответственности.
* {+Команда, Action, Transaction	Command+}	Представляет действие. Объект команды заключает в себе само действие и его параметры.
* {+Интерпретатор	Interpreter+}	Решает часто встречающуюся, но подверженную изменениям, задачу.
* {+Итератор, Cursor	Iterator+}	Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого из объектов, входящих в состав агрегации.
* {+Посредник	Mediator+}	Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.
* {+Хранитель	Memento+}	Позволяет не нарушая инкапсуляцию зафиксировать и сохранить внутренние состояния объекта так, чтобы позднее восстановить его в этих состояниях.
* {+Null Object	Null Object+}	Предотвращает нулевые указатели, предоставляя объект «по умолчанию».
* {+Наблюдатель или Издатель-подписчик	Observer+}	Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.
* Слуга[en]	Servant	Используется для обеспечения общей функциональности группе классов.
* Спецификация	Specification	Служит для связывания бизнес-логики.
* {+Состояние	State+}	Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.
* {+Стратегия	Strategy+}	Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.
* {+Шаблонный метод	Template method+}	Определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
* {+Посетитель	Visitor+}	Описывает операцию, которая выполняется над объектами других классов. При изменении класса Visitor нет необходимости изменять обслуживаемые классы.
* Простая политика	Simple Policy
* Event listener	Event listener
* Одноразовый посетитель[en]	Single-serving visitor	Оптимизирует реализацию шаблона посетитель, который инициализируется, единожды используется, и затем удаляется.
* Иерархический посетитель[en]	Hierarchical visitor	Предоставляет способ обхода всех вершин иерархической структуры данных (напр. древовидной).
* Concurrency — Параллелизм

!!!! Частные

!!!!! Шаблоны параллельного программирования (Concurrency)

Используются для более эффективного написания многопоточных программ, и предоставляет готовые решения проблем синхронизации.

* Active Object	Active object	Служит для отделения потока выполнения метода от потока, в котором он был вызван. Использует шаблоны асинхронный вызов методов и планировщик.
* Balking[en]	Balking	Служит для выполнения действия над объектом только тогда, когда тот находится в корректном состоянии.
* Binding properties	Комбинирует несколько наблюдателей для обеспечения синхронизации свойств в различных объектах[7].
* Обмен сообщениями[en]	Messaging pattern, Messaging design pattern (MDP)	Позволяет компонентам и приложениям обмениваться информацией (сообщениями).
* Блокировка с двойной проверкой	Double checked locking	Предназначен для уменьшения накладных расходов, связанных с получением блокировки.
* Event-based asynchronous[en]	Event-Based Asynchronous	Адресные проблемы с Асинхронным паттерном, которые возникают в программах с несколькими потоками[8].
* Охраняемая приостановка	Guarded suspension	Используется для блокировки выполнения действия над объектом только тогда, когда тот находится в корректном состоянии.
* Half-Sync/Half-Async		
* Leaders/followers		
* Блокировка	Lock	Один поток блокирует ресурс для предотвращения доступа или изменения его другими потоками[9].
* Монитор	Monitor	Объект, предназначенный для безопасного использования более чем одним потоком.
* Reactor[en]	Reactor	Предназначен для синхронной передачи запросов сервису от одного или нескольких источников.
* Read/write lock[en]	Read/write lock	Позволяет нескольким потокам одновременно считывать информацию из общего хранилища, но позволяя только одному потоку в текущий момент времени её изменять.
* Планировщик	Scheduler	Обеспечивает механизм реализации политики планирования, но при этом не зависящих ни от одной конкретной политики.
* Thread pool[en]		Предоставляет пул потоков для обработки заданий, представленных обычно в виде очереди.
* Thread-Specific Storage[en]		Служит для предоставления различных глобальных переменных для разных потоков.
* Однопоточное выполнение	Single thread execution	Препятствует конкурентному вызову метода, тем самым запрещая параллельное выполнение этого метода.
* Кооперативный паттерн	Cooperative pattern	Обеспечивает механизм безопасной остановки потоков исполнения, используя общий флаг для сигнализирования прекращения работы потоков.

!!!!! Шаблоны архитектуры системы

* Model-View-Controller (MVC) Модель-представление-контроллер.
* Model-View-Presenter.
* Model-View-ViewModel.
* Presentation-Abstraction-Control.
* Naked objects[10].
* Hierarchical Model-View-Controller.
* View-Interactor-Presenter-Entity-Routing (VIPER).

!!!!! Enterprise

* Active Record — способ доступа к данным реляционных баз данных в объектно-ориентированном программировании.
* Business Delegate.
* Composite Entity/Составная Сущность.
* Composite View.
* DAO (Data Access Object) Объект Доступа к Данным.
* Dispatcher View.
* Front Controller.
* Intercepting Filter.
* Registry.
* Service Activator.
* Service Locator/Локатор Служб.
* Service to Worker.
* Session Facade/Фасад Сессии.
* Transfer Object Assembler.
* Transfer Object/Объект Перемещения.
* Value List Handler/Обработчик Списка Значений.
* View Helper.
* Unit of Work.

!!!!! Прочие

* Repository/Хранилище.

!!!! Другие типы шаблонов

Также на сегодняшний день существует ряд других шаблонов.

* Carrier Rider Mapper описывают предоставление доступа к хранимой информации.
* Аналитические шаблоны описывают основной подход для составления требований для программного обеспечения (requirement analysis) до начала самого процесса программной разработки.
* Коммуникационные шаблоны описывают процесс общения между отдельными участниками/сотрудниками организации.
* Организационные шаблоны описывают организационную иерархию предприятия/фирмы
* Антипаттерны (Anti-Design-Patterns) описывают, как не следует поступать при разработке программ, показывая характерные ошибки в дизайне и в реализации.